Assets {
  Id: 13930081442646637908
  Name: "easyStorage"
  PlatformAssetType: 5
  TemplateAsset {
    ObjectBlock {
      RootId: 2567066855685213697
      Objects {
        Id: 2567066855685213697
        Name: "TemplateBundleDummy"
        Transform {
          Location {
          }
          Rotation {
          }
          Scale {
            X: 1
            Y: 1
            Z: 1
          }
        }
        Folder {
          BundleDummy {
            ReferencedAssets {
              Id: 2805963157639982729
            }
          }
        }
      }
    }
    Assets {
      Id: 2805963157639982729
      Name: "@easyStorage"
      PlatformAssetType: 5
      TemplateAsset {
        ObjectBlock {
          RootId: 3454049609351584052
          Objects {
            Id: 3454049609351584052
            Name: "@easyStorage"
            Transform {
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 4781671109827199097
            ChildIds: 17902948058519089468
            ChildIds: 713008881287934061
            UnregisteredParameters {
              Overrides {
                Name: "cs:STORAGE_VERSION"
                Int: 1
              }
              Overrides {
                Name: "cs:SHARED_STORAGE_VERSION"
                Int: 1
              }
              Overrides {
                Name: "cs:SHARED_STORAGE_KEY"
                NetReference {
                  Type {
                    Value: "mc:enetreferencetype:unknown"
                  }
                }
              }
              Overrides {
                Name: "cs:SHARED_STORAGE_KEY:tooltip"
                String: "[Optional] Shared Storage Net Reference"
              }
              Overrides {
                Name: "cs:SHARED_STORAGE_KEY:category"
                String: "easyStorage_API"
              }
              Overrides {
                Name: "cs:STORAGE_VERSION:tooltip"
                String: "Current version of regular Storage data"
              }
              Overrides {
                Name: "cs:STORAGE_VERSION:category"
                String: "easyStorage_API"
              }
              Overrides {
                Name: "cs:SHARED_STORAGE_VERSION:tooltip"
                String: "[Optional] Current version of Shared Storage data."
              }
              Overrides {
                Name: "cs:SHARED_STORAGE_VERSION:category"
                String: "easyStorage_API"
              }
            }
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            EditorIndicatorVisibility {
              Value: "mc:eindicatorvisibility:visiblewhenselected"
            }
            Folder {
              IsFilePartition: true
              FilePartitionName: "_easyStorage"
            }
          }
          Objects {
            Id: 17902948058519089468
            Name: "Modules"
            Transform {
              Location {
              }
              Rotation {
              }
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 3454049609351584052
            ChildIds: 2986038103115172940
            ChildIds: 6736355531561656281
            UnregisteredParameters {
              Overrides {
                Name: "cs:easyStorageAPI"
                AssetReference {
                  Id: 9898829530473888574
                }
              }
              Overrides {
                Name: "cs:BitArray"
                AssetReference {
                  Id: 16087391583451673026
                }
              }
              Overrides {
                Name: "cs:Enum"
                AssetReference {
                  Id: 10876574309383257670
                }
              }
              Overrides {
                Name: "cs:MessagePack"
                AssetReference {
                  Id: 7103355485084642100
                }
              }
              Overrides {
                Name: "cs:QuickBase64"
                AssetReference {
                  Id: 7645259355759957035
                }
              }
              Overrides {
                Name: "cs:LibLZW"
                AssetReference {
                  Id: 225378120198817764
                }
              }
            }
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            EditorIndicatorVisibility {
              Value: "mc:eindicatorvisibility:visiblewhenselected"
            }
            Folder {
              IsFilePartition: true
              FilePartitionName: "Modules"
            }
          }
          Objects {
            Id: 2986038103115172940
            Name: "DefaultContext"
            Transform {
              Location {
              }
              Rotation {
              }
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 17902948058519089468
            ChildIds: 4765886392145235493
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            EditorIndicatorVisibility {
              Value: "mc:eindicatorvisibility:visiblewhenselected"
            }
            Folder {
              IsFilePartition: true
              FilePartitionName: "DefaultContext"
            }
          }
          Objects {
            Id: 4765886392145235493
            Name: "InitModules"
            Transform {
              Location {
              }
              Rotation {
              }
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 2986038103115172940
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            EditorIndicatorVisibility {
              Value: "mc:eindicatorvisibility:visiblewhenselected"
            }
            Script {
              ScriptAsset {
                Id: 10904663549924109574
              }
            }
          }
          Objects {
            Id: 6736355531561656281
            Name: "ClientContext"
            Transform {
              Location {
              }
              Rotation {
              }
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 17902948058519089468
            ChildIds: 4363771084980292245
            Collidable_v2 {
              Value: "mc:ecollisionsetting:forceoff"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:forceoff"
            }
            EditorIndicatorVisibility {
              Value: "mc:eindicatorvisibility:visiblewhenselected"
            }
            NetworkContext {
            }
          }
          Objects {
            Id: 4363771084980292245
            Name: "InitModules"
            Transform {
              Location {
              }
              Rotation {
              }
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 6736355531561656281
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            EditorIndicatorVisibility {
              Value: "mc:eindicatorvisibility:visiblewhenselected"
            }
            Script {
              ScriptAsset {
                Id: 10904663549924109574
              }
            }
          }
          Objects {
            Id: 713008881287934061
            Name: "easyStorage_README"
            Transform {
              Location {
              }
              Rotation {
              }
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 3454049609351584052
            UnregisteredParameters {
              Overrides {
                Name: "cs:DataExample"
                AssetReference {
                  Id: 6526640698689085722
                }
              }
            }
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            EditorIndicatorVisibility {
              Value: "mc:eindicatorvisibility:visiblewhenselected"
            }
            Script {
              ScriptAsset {
                Id: 4002058138349424369
              }
            }
          }
        }
        PrimaryAssetId {
          AssetType: "None"
          AssetId: "None"
        }
      }
    }
    Assets {
      Id: 6526640698689085722
      Name: "DataExample"
      PlatformAssetType: 3
      TextAsset {
        Text: "\n---@class DataExapmple\n---@field FM_DATA string\n---@field FM_DATA_15K string\nlocal m = {}\n\n\n-- Lua tables encoded my MessagePck and then Base64\nm.FM_DATA = [[\n    iKpsb2dvdXREYXRhg6hwb3NpdGlvbpIAgKlmYXJtTG9jYWzDqXJvdGF0aW9uWstAXbh9gAAA\n    ALFyZWNlaXZlZEluc3RhR3JvdwGwU1RBVFNEQVRBVkVSU0lPTgGpbmV3UGVyc29uAKxhY2hp\n    ZXZlbWVudHPeAC2rQV9CYWNrcGFjazUBqUFfU2hvdmVsNAGrQV9CYWNrcGFjazIBqEFfUGxv\n    dHMzAatBX05ldFdvcnRoNgCpQV9TdGFibGUxAKZBX1JvZDIBqUFfU2hvdmVsMwGsQV9OZXRX\n    b3J0aDEyAKxBX05ldFdvcnRoMTEArkFfQmFyblN0b3JhZ2UxAKtBX05ldFdvcnRoMwGmQV9S\n    b2QxAKhBX1Bsb3RzMQGuQV9CYXJuU3RvcmFnZTIBq0FfTmV0V29ydGg3AKtBX0JhY2twYWNr\n    MwGoQV9QbG90czUAqUFfU2hvdmVsMQCrQV9OZXRXb3J0aDQBq0FfQmFja3BhY2sxAKlBX1No\n    b3ZlbDIBrkFfQmFyblN0b3JhZ2U1AKxBX05ldFdvcnRoMTAAq0FfTmV0V29ydGgyAatBX0Jh\n    Y2twYWNrNAGrQV9EZXRlY3RvcjQBqEFfUGxvdHM0AKZBX1JvZDMBpkFfUm9kNAGrQV9EZXRl\n    Y3RvcjMBqUFfU3RhYmxlNAGpQV9TdGFibGUyAa5BX0Jhcm5TdG9yYWdlNACpQV9TdGFibGUz\n    AahBX1Bsb3RzNgCrQV9OZXRXb3J0aDUAq0FfTmV0V29ydGgxAahBX1Bsb3RzMgGuQV9CYXJu\n    U3RvcmFnZTMArEFfTmV0V29ydGgxMwCrQV9EZXRlY3RvcjEAq0FfTmV0V29ydGg5AKtBX0Rl\n    dGVjdG9yMgGrQV9OZXRXb3J0aDgAqWludmVudG9yeYO1cGFja2VkTWV0YWxDb2xsZWN0aW9u\n    2TkxMDczODQwMTI4LDMzNTU0OTQ1LDEzNDIxNzcyOSwwLDE2LDI2MjE0NCwyNTYsNDA1ODA3\n    Nzc0LDOhdgS1cGFja2VkTWV0YWxJdGVtQ291bnRzgqVNRDIzMQGlTUQyMzgBpXN0YXRz3gA0\n    sURldGVjdGlvbk1heERlcHRoFLVSZXNvdXJjZVRvbWF0b1BsYW50ZWQAslJlc291cmNlVG9t\n    YXRvU29sZACpQmFybkxldmVsBbtSZXNvdXJjZVN0cmF3YmVycnlIYXJ2ZXN0ZWQEq1Nob3Zl\n    bExldmVsBbZSZXNvdXJjZVB1bXBraW5QbGFudGVkALNSZXNvdXJjZVB1bXBraW5Tb2xkAK5S\n    ZXNvdXJjZVRvbWF0bwCwSW5zdGFHcm93QnVuZGxlMQCvUmVzb3VyY2VQdW1wa2luAK9GaXNo\n    aW5nUm9kTGV2ZWwFsEluc3RhR3Jvd0J1bmRsZTIAsE1vbmV5QWNjdW11bGF0ZWTNU3iyUmVz\n    b3VyY2VXYXRlcm1lbG9uAK1SZXNvdXJjZUdyYXBlALlSZXNvdXJjZVdhdGVybWVsb25QbGFu\n    dGVkALlSZXNvdXJjZVN0cmF3YmVycnlQbGFudGVkCLRSZXNvdXJjZUdyYXBlUGxhbnRlZBC5\n    RGFpbHlSZXdhcmRMYXN0U2VydmVyVGltZc5hkQHFslJlc291cmNlQ2Fycm90U29sZACwSW5z\n    dGFHcm93QnVuZGxlNAC0UmVzb3VyY2VXaGVhdFBsYW50ZWQAt1Jlc291cmNlQ2Fycm90SGFy\n    dmVzdGVkAK9EZXRlY3Rpb25SYWRpdXPNCJiuUmVzb3VyY2VDYXJyb3QArVBsb3RzVW5sb2Nr\n    ZWQUtlJlc291cmNlU3RyYXdiZXJyeVNvbGQAsVJlc291cmNlR3JhcGVTb2xkAKtTdGFibGVM\n    ZXZlbAqwSW5zdGFHcm93QnVuZGxlNQCwSW5zdGFHcm93QnVuZGxlMwCvQ3VyTWV0YWxTdG9y\n    YWdlArZSZXNvdXJjZVdhdGVybWVsb25Tb2xkALdJbnN0YUdyb3dMYXN0U2VydmVyVGltZc5h\n    kQHFsUluc3RhR3Jvd0xhc3RUaW1lAKVNb25lec4AsjmftlJlc291cmNlV2hlYXRIYXJ2ZXN0\n    ZWQArVJlc291cmNlV2hlYXQAqVN0YXJ0VGltZc5f3KEguFJlc291cmNlUHVtcGtpbkhhcnZl\n    c3RlZACyUmVzb3VyY2VTdHJhd2JlcnJ5BK1CYWNrcGFja0xldmVsFbJNZXRhbERldGVjdG9y\n    TGV2ZWwFtlJlc291cmNlR3JhcGVIYXJ2ZXN0ZWQAqUluc3RhR3Jvdwq7UmVzb3VyY2VXYXRl\n    cm1lbG9uSGFydmVzdGVkALFSZXNvdXJjZVdoZWF0U29sZAC1UmVzb3VyY2VDYXJyb3RQbGFu\n    dGVkALJEYWlseVJld2FyZExhc3REYXkAs0RhaWx5UmV3YXJkTGFzdFRpbWUAt1Jlc291cmNl\n    VG9tYXRvSGFydmVzdGVkAKlwbG90c0RhdGHcABSDqXN0YXJ0VGltZc5f3KPdrXBsYW50UmVz\n    b3VyY2WyUmVzb3VyY2VTdHJhd2JlcnJ5qWluc3RhR3JvdwGDqXN0YXJ0VGltZc5f3KPfrXBs\n    YW50UmVzb3VyY2WyUmVzb3VyY2VTdHJhd2JlcnJ5qWluc3RhR3JvdwGDqXN0YXJ0VGltZc5f\n    3KPhrXBsYW50UmVzb3VyY2WyUmVzb3VyY2VTdHJhd2JlcnJ5qWluc3RhR3JvdwCDqXN0YXJ0\n    VGltZc5f3KPlrXBsYW50UmVzb3VyY2WyUmVzb3VyY2VTdHJhd2JlcnJ5qWluc3RhR3JvdwCD\n    qXN0YXJ0VGltZc5f3KRkrXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZalpbnN0YUdyb3cA\n    g6lzdGFydFRpbWXOX9ykZa1wbGFudFJlc291cmNlrVJlc291cmNlR3JhcGWpaW5zdGFHcm93\n    AIOpc3RhcnRUaW1lzl/cpGatcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlqWluc3RhR3Jv\n    dwCDqXN0YXJ0VGltZc5f3KRnrXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZalpbnN0YUdy\n    b3cAg6lzdGFydFRpbWXOX9yka61wbGFudFJlc291cmNlrVJlc291cmNlR3JhcGWpaW5zdGFH\n    cm93AIOpc3RhcnRUaW1lzl/cpGqtcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlqWluc3Rh\n    R3JvdwCDqXN0YXJ0VGltZc5f3KRprXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZalpbnN0\n    YUdyb3cAg6lzdGFydFRpbWXOX9ykaK1wbGFudFJlc291cmNlrVJlc291cmNlR3JhcGWpaW5z\n    dGFHcm93AIOpc3RhcnRUaW1lzl/cpGytcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlqWlu\n    c3RhR3JvdwCDqXN0YXJ0VGltZc5f3KRtrXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZalp\n    bnN0YUdyb3cBg6lzdGFydFRpbWXOX9ykbq1wbGFudFJlc291cmNlrVJlc291cmNlR3JhcGWp\n    aW5zdGFHcm93AIOpc3RhcnRUaW1lzl/cpG+tcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBl\n    qWluc3RhR3JvdwCDqXN0YXJ0VGltZc5f3KRyrXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFw\n    ZalpbnN0YUdyb3cAg6lzdGFydFRpbWXOX9ykca1wbGFudFJlc291cmNlrVJlc291cmNlR3Jh\n    cGWpaW5zdGFHcm93AIOpc3RhcnRUaW1lzl/cpHGtcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdy\n    YXBlqWluc3RhR3JvdwCDqXN0YXJ0VGltZc5f3KRwrXBsYW50UmVzb3VyY2WtUmVzb3VyY2VH\n    cmFwZalpbnN0YUdyb3cB\n]]\n\nm.FM_DATA_15K = [[\n    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\n    a7HKRp1KIcpGq4tAykbmDwHKRgvatMpHGAftykYzJxTKRdJ9GMpHBQGoykYOpWrKRap1UspG\n    KPGFykcf4LjKR0Ati8pG0BKwykekWNzKRphUyspHkMzmykYEq3TKRZhS2cpG1UcJykaZxPTK\n    RcKcGMpHbQYtykO5o9XKRbz8pMpFRPCnyka33DHKRCi1ucpEOWvwykPwAGLKRN3lispGys9i\n    ykavetLKRXDzZspHT6IJykbkHGzKRw2K98pEDTb7ykZJpHHKROU0JspGNo8Gykdc4WbKRZ+F\n    WspGM0llyka+Wk/KRwpOXcpHI2MvykdCTF7KRuqzRspHgfVlykbdsmvKRnOPOMpFTVLEykas\n    i7bKRkRV78pGDMLiykeCRvbKR5AI58pHHbsBykUCjUrKRNLvMcpEjL+jykaELKvKRwdSjspG\n    kXP7ykX1TGPKRIPC2cpHUQe6ykczk6TKR2ts6MpHMiplykZk50XKRxSNaspFdyCyykVoJPLK\n    RoMu7MpBhY8gykcZFMbKRuCihMpG/8pqykcPGIzKRPCUGcpHgh4XykbRYAXKRJ/9XspFznb9\n    ykcHoHfKRkNEYspGmWsTykdOBO7KRjHIyMpGWkN4ykSIFq7KReHJscpG/DRbykYG7PLKRwvb\n    FMpHI2dXykWJGiLKRxIhjcpGk1F7ykZtfA7KRjSKZcpHiFCCykaHga7KR0hQoMpHCW62ykee\n    Ga7KRou13spHCpxMyka8qKvKRy6r+spG+7WIykU3ICHKRxnDTcpHGMvDykd+F8LKRszC5MpH\n    lOYoyka9OsHKRbhz5cpHFWwaykeRBeHKRwZQrMpGSYQMykdSaAjKRLiA0MpHhOazykVBCIrK\n    RzOdecpFuDqzykXy6IzKR2OVdcpGhVykykZhVHfKRYvJ2MpEgLD7ykbm9UnKRrM0zspGmLKJ\n    ykXbIZDKRtr2sspHQ2nKykdKQa3KRswpx8pGUhlZykevtX/KReIa1cpGQnZOykbGZ77KR4cu\n    4spGyHhNykcTEK7KR4KcucpFteq0ykYxfsyxcmVjZWl2ZWRJbnN0YUdyb3cBqmxvZ291dERh\n    dGGDqHBvc2l0aW9ukgCQqWZhcm1Mb2NhbMOpcm90YXRpb25aykLtw+ylc3RhdHPeADStUGxv\n    dHNVbmxvY2tlZBSzUmVzb3VyY2VQdW1wa2luU29sZACwTW9uZXlBY2N1bXVsYXRlZM1TeK1C\n    YWNrcGFja0xldmVsFbVSZXNvdXJjZVRvbWF0b1BsYW50ZWQAt1Jlc291cmNlVG9tYXRvSGFy\n    dmVzdGVkALJSZXNvdXJjZVRvbWF0b1NvbGQAq1N0YWJsZUxldmVsCrlSZXNvdXJjZVN0cmF3\n    YmVycnlQbGFudGVkCLNEYWlseVJld2FyZExhc3RUaW1lAK9EZXRlY3Rpb25SYWRpdXPNCJiu\n    UmVzb3VyY2VDYXJyb3QAr0N1ck1ldGFsU3RvcmFnZQKyUmVzb3VyY2VDYXJyb3RTb2xkALtS\n    ZXNvdXJjZVdhdGVybWVsb25IYXJ2ZXN0ZWQAsURldGVjdGlvbk1heERlcHRoFLJEYWlseVJl\n    d2FyZExhc3REYXkAr1Jlc291cmNlUHVtcGtpbgC0UmVzb3VyY2VHcmFwZVBsYW50ZWQQtVJl\n    c291cmNlQ2Fycm90UGxhbnRlZACxUmVzb3VyY2VXaGVhdFNvbGQAuVJlc291cmNlV2F0ZXJt\n    ZWxvblBsYW50ZWQAuURhaWx5UmV3YXJkTGFzdFNlcnZlclRpbWXOYZEBxa1SZXNvdXJjZUdy\n    YXBlALBJbnN0YUdyb3dCdW5kbGUxAKlJbnN0YUdyb3cKu1Jlc291cmNlU3RyYXdiZXJyeUhh\n    cnZlc3RlZASwSW5zdGFHcm93QnVuZGxlNQCyTWV0YWxEZXRlY3RvckxldmVsBatTaG92ZWxM\n    ZXZlbAWyUmVzb3VyY2VTdHJhd2JlcnJ5BLhSZXNvdXJjZVB1bXBraW5IYXJ2ZXN0ZWQAqVN0\n    YXJ0VGltZc5f3KEgrVJlc291cmNlV2hlYXQAtlJlc291cmNlV2hlYXRIYXJ2ZXN0ZWQAslJl\n    c291cmNlV2F0ZXJtZWxvbgClTW9uZXnOALI5n7FJbnN0YUdyb3dMYXN0VGltZQC3SW5zdGFH\n    cm93TGFzdFNlcnZlclRpbWXOYZEBxbZSZXNvdXJjZVdhdGVybWVsb25Tb2xkAKlCYXJuTGV2\n    ZWwFr0Zpc2hpbmdSb2RMZXZlbAWwSW5zdGFHcm93QnVuZGxlMwCuUmVzb3VyY2VUb21hdG8A\n    sVJlc291cmNlR3JhcGVTb2xkALZSZXNvdXJjZVN0cmF3YmVycnlTb2xkALBJbnN0YUdyb3dC\n    dW5kbGU0ALRSZXNvdXJjZVdoZWF0UGxhbnRlZAC3UmVzb3VyY2VDYXJyb3RIYXJ2ZXN0ZWQA\n    sEluc3RhR3Jvd0J1bmRsZTIAtlJlc291cmNlUHVtcGtpblBsYW50ZWQAtlJlc291cmNlR3Jh\n    cGVIYXJ2ZXN0ZWQApW51bXMy3AH0ysYVZhfKxwawUspD44UZysck+znKxLbh6MpGbF7tykah\n    GIzKRQskccrGEE3vykaXJ+fKxJEmesrHDXcQysaTXD7Kx4NSTcpFoSHBysbnfh7KRzAjAcrF\n    SlTqykW/s6TKxy4bg8rGkH3VykbkL3fKxMHLvcrFARKQykeZL2TKxxy+ncpGQT6KykGAtU/K\n    xn5bzsrGRFFJysaU03fKQ5HSpcrEh+wJykZdHM3KxmhNWcrDFrhxykcETYHKRIMnIcpHNggP\n    ysc0j1DKxpGRHMrGA+6wysYH+0TKRFMJT8rGlLBQysbv1CLKRtj8FcrFBkh5ysZzXJnKRd6d\n    pspEdJsSysYEumDKRgZy3cpDSa2sykZzksLKRp2RespGMXuqysWq9iDKRvRaB8pDilWTykNs\n    /D/KRREcgMpFz/m9ysUyWJPKRpC09srEvvZtyka0QQHKRa6wfMpGtZGTysJzX2bKxvQMH8pE\n    v7WVysYcGOrKRYHIAspFxxBlysXNNOTKReBKGMpFU689ykerDlLKRZbvWMrGQFLcykafGlTK\n    x1qFLspDbB7Yysa6JuHKxrvpZcpGPkV3ykQRTnLKR5o3UspGFj/VysSP6ErKxtvZLcpFbT/B\n    ykZnMybKxYMHIsrF5SnLysS0LLXKRxC+OcpCqMkYykYqFiDKxqJjtcrFRkv5ysTe+y7Kxy4N\n    28rGwExQykNwHvnKRrRbHsrGt6dqysZqG4DKRHOvLspG3nW2ykSaZh7KRCFcYcrGQdbPykcH\n    aefKRaUOF8rGuMr2ykanR1TKRkNcnMrF0yVDykbf7pTKRCoB5MpGRnESykaiewjKRQeTvspG\n    aHLtysbEreLKxmN2gcrGGm5eysUgQXvKRpg8jcpFybFkykcWZgXKxi54YcpEVuLZykMnrrjK\n    w4929spFGeaVykQI3Y3KxZ0C6srFiLbvykRpMADKxY1Ru8rFVkJMysVryU/KwwHW8MpGhzLV\n    ysbmaj3KxYM6SMrHKTqhysagjwrKxR1uu8rGfC3tykOm00XKQh3YdcrEsffNykWn/KHKRfld\n    McpFoUjxysbuSETKRgoTE8pGPZWoysXFTILKRik4c8rEhexKykcbBojKx0xZncrGmzSOykRw\n    B4XKxWBuK8rFFMq0ykahWu/KRYsRl8rHNufiysYL9l3KRbcE18rEljX5ysYk0f3Kx0pWOspF\n    CWWcykZym+3KRofiRsrGp+2jysckR3PKxUtkZ8pHIfr6ykTVzCPKxokhNsrDrMB2ykaS2VXK\n    RQYuWMpGhiyZykXhju3KRiXJf8rHWDalykZK2tDKRc902MrGmRVtykXG0xbKxi/BL8rFZtas\n    ykZnFArKQ77E9srFXA+eykX+35/KxpIAuspGy+41ysJOWEPKxx0sXMrFOX8YysWdyLnKxlYf\n    x8pDhQZ/ysWBt5bKRvo7G8rHCQtwykcnETbKRm5sg8pDG0SmykcIGRDKRReqVspF0XlFysTg\n    kW3KxtNEaspGcxkHykYaYAnKxZj3HsrFwF6OykXBuAvKxsrPGMpFwdcaykcBZgjKRStwXMpG\n    HmZpysVzA7LKRtmqt8rDUGaxysQIBQPKxYdvhcrHDaEXysbD3E7KxT3tT8rGYTM+ykaOPlzK\n    xY43d8rGd6kjysYmr8HKxlBjTMpE+pNUykbXmVXKw4vKTcpDHBDqykcZafXKRo1UY8pFFTew\n    ysaGxYbKxoBEGMpHDZuLykYTbnnKRVnYdcpGln+SykXgLtzKxQ4ObcrGmmibysdS4ovKxgkp\n    nsrFRNOjysce2xbKRIk9XspHIucuysbwvTzKx3tj8crFs4xcykZ+C1vKxCrAkspGbgrSysOe\n    XWTKxaD64srEJl2CyscrjbTKwxWuRcrHDz4jykYo1k3KRmA5EspGl0KdysTboiDKRhTdzMrF\n    Vr5gysNj6azKxkndZspGTpyPysQIOYDKxqySecpDvQE+ykeVwSLKxrAvOspEtREdysVXi+zK\n    RhxK6spG2DDZykbK/vzKRRDUH8pGb6o7ykZA8F7KRtl8MspFFQWnykeUAATKRowvmMpHWgcb\n    ysYQ6x/Kxs+HbcrG2wBHykUAkiDKxUjTd8pG1Y+vysZmIPDKxME5c8pFBB/fykbrb2PKRIke\n    PMpGCVruykZBkSbKRhqPPcpFuCHnysZF3ETKxhtzHMpFxvHoysbDTEfKRucf+spFsSQOysYF\n    TWTKRsBDaMrGrKuEysWzVpDKQo+MY8pEb3iTysav4j7Kxl2wX8pHK5qhysbdwsbKRcQ2kMrF\n    y1YFykXKVz/KRkqosspC6IoOykWqpvLKRgHkdcrHj9MDykYON9DKx0KqF8pGKC65ykVKzdHK\n    Rc65rspGD6UEysWJMI7KxdpxUsrFj6XBykYnQwbKxkTYncpFf3k6ykVhqYnKxWIsdcrGDZsv\n    ysbPIjrKRuRNGcpG5FrJykZaRvnKRN7dsMrF87qgykYLEC7KxxvaLspGdsUHykV8/fbKwqcT\n    FcpFp7pwysXCr8nKxJfHLspHCOJzykWC5qLKRKE/VMrGssdEykS9qP3KR0tPecrF+6NTyscY\n    zefKRdMTosrGENUFykZgzyfKRuw6O8pGMUd3ykdsPLnKw8vKS8rGhmPSykXTKCrKRhGL0spE\n    G8v6ysYsZD/KRvbjR8pG/JezykYKsfHKRm62+spDoYGzykbLo9fKxvSvTcrHAX5pysZreEPK\n    xRrol8pFV9zZysXN4WvKxkoYcMrHCgknykZDLcLKxpT3FcrGmGo5ykbv5HzKxllavcrGMr27\n    ysSgpkvKxUIta8pGg9OuykZ4hczKx4wuUcpEFTp1ysO7Tl/KxhHUQcrGMn1wysazZ7LKwwkY\n    RMpFj1X4ykaVOiXKRiSrPsrGVUrdysUhaaDKRvafFMrGjUWpysYso1HKxqp968rFh4qAysZi\n    ePnKxa6KCMpG22P0ykWL9C7KxsjLGMpGYbnVysXtvIfKxwrB2spHPAoSykYtPizKRbWKysrG\n    qfvZysPcCSXKRv8SMsrGBl3+ysSY9ifKxbvDIsrHgMYDykSF8ubKRsTZ3spEvYUnysb2LgnK\n    xUJRZMrEhKGpysal8SDKx2p29crGAwq4ykXn9FXKw6Ojj8rHGgf0yscgXG7KxvIAfMpG3hYU\n    ysX+ZarKxwZrXcrGg4vcykVn+ZPKRiGifcrFrxHnysW1/UrKR05ptcrEe/TeysW083vKRXet\n    TspFPOppysVE4HnKRC+fuspE+fTJysPMtFTKxO9QGMpFyFiXykUt2GnKxwsH0MrGJyhVysSH\n    CrbKxUYU2cpGlPanykYXREzKxDzpFcrGSVzvykYLKTjKw6ShZalwbG90c0RhdGHcABSDqXN0\n    YXJ0VGltZc5f3KPdqWluc3RhR3JvdwGtcGxhbnRSZXNvdXJjZbJSZXNvdXJjZVN0cmF3YmVy\n    cnmDqXN0YXJ0VGltZc5f3KPfqWluc3RhR3JvdwGtcGxhbnRSZXNvdXJjZbJSZXNvdXJjZVN0\n    cmF3YmVycnmDqXN0YXJ0VGltZc5f3KPhqWluc3RhR3JvdwCtcGxhbnRSZXNvdXJjZbJSZXNv\n    dXJjZVN0cmF3YmVycnmDqXN0YXJ0VGltZc5f3KPlqWluc3RhR3JvdwCtcGxhbnRSZXNvdXJj\n    ZbJSZXNvdXJjZVN0cmF3YmVycnmDqXN0YXJ0VGltZc5f3KRkqWluc3RhR3JvdwCtcGxhbnRS\n    ZXNvdXJjZa1SZXNvdXJjZUdyYXBlg6lzdGFydFRpbWXOX9ykZalpbnN0YUdyb3cArXBsYW50\n    UmVzb3VyY2WtUmVzb3VyY2VHcmFwZYOpc3RhcnRUaW1lzl/cpGapaW5zdGFHcm93AK1wbGFu\n    dFJlc291cmNlrVJlc291cmNlR3JhcGWDqXN0YXJ0VGltZc5f3KRnqWluc3RhR3JvdwCtcGxh\n    bnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlg6lzdGFydFRpbWXOX9yka6lpbnN0YUdyb3cArXBs\n    YW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZYOpc3RhcnRUaW1lzl/cpGqpaW5zdGFHcm93AK1w\n    bGFudFJlc291cmNlrVJlc291cmNlR3JhcGWDqXN0YXJ0VGltZc5f3KRpqWluc3RhR3JvdwCt\n    cGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlg6lzdGFydFRpbWXOX9ykaKlpbnN0YUdyb3cA\n    rXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZYOpc3RhcnRUaW1lzl/cpGypaW5zdGFHcm93\n    AK1wbGFudFJlc291cmNlrVJlc291cmNlR3JhcGWDqXN0YXJ0VGltZc5f3KRtqWluc3RhR3Jv\n    dwGtcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlg6lzdGFydFRpbWXOX9ykbqlpbnN0YUdy\n    b3cArXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZYOpc3RhcnRUaW1lzl/cpG+paW5zdGFH\n    cm93AK1wbGFudFJlc291cmNlrVJlc291cmNlR3JhcGWDqXN0YXJ0VGltZc5f3KRyqWluc3Rh\n    R3JvdwCtcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlg6lzdGFydFRpbWXOX9ykcalpbnN0\n    YUdyb3cArXBsYW50UmVzb3VyY2WtUmVzb3VyY2VHcmFwZYOpc3RhcnRUaW1lzl/cpHGpaW5z\n    dGFHcm93AK1wbGFudFJlc291cmNlrVJlc291cmNlR3JhcGWDqXN0YXJ0VGltZc5f3KRwqWlu\n    c3RhR3JvdwGtcGxhbnRSZXNvdXJjZa1SZXNvdXJjZUdyYXBlqWludmVudG9yeYO1cGFja2Vk\n    TWV0YWxJdGVtQ291bnRzgqVNRDIzMQGlTUQyMzgBtXBhY2tlZE1ldGFsQ29sbGVjdGlvbtk5\n    MTA3Mzg0MDEyOCwzMzU1NDk0NSwxMzQyMTc3MjksMCwxNiwyNjIxNDQsMjU2LDQwNTgwNzc3\n    NCwzoXYEsFNUQVRTREFUQVZFUlNJT04BrGFjaGlldmVtZW50c94ALatBX05ldFdvcnRoNwCu\n    QV9CYXJuU3RvcmFnZTIBqUFfU2hvdmVsMgGuQV9CYXJuU3RvcmFnZTMAq0FfTmV0V29ydGgz\n    Aa5BX0Jhcm5TdG9yYWdlNACrQV9CYWNrcGFjazEAq0FfQmFja3BhY2syAalBX1N0YWJsZTQB\n    qEFfUGxvdHM0AKZBX1JvZDEAqUFfU3RhYmxlMgGmQV9Sb2QyAalBX1Nob3ZlbDMBq0FfRGV0\n    ZWN0b3I0AatBX0RldGVjdG9yMgGoQV9QbG90czEBpkFfUm9kMwGrQV9OZXRXb3J0aDQBq0Ff\n    QmFja3BhY2s1AahBX1Bsb3RzNgCrQV9EZXRlY3RvcjEAq0FfTmV0V29ydGg4AKtBX05ldFdv\n    cnRoOQCsQV9OZXRXb3J0aDEzAKxBX05ldFdvcnRoMTEAqEFfUGxvdHMyAatBX05ldFdvcnRo\n    MQGpQV9TdGFibGUzAatBX05ldFdvcnRoNQCoQV9QbG90czUApkFfUm9kNAGrQV9CYWNrcGFj\n    azMBqUFfU2hvdmVsNAGrQV9EZXRlY3RvcjMBqUFfU3RhYmxlMQCuQV9CYXJuU3RvcmFnZTUA\n    rEFfTmV0V29ydGgxMACrQV9OZXRXb3J0aDYArkFfQmFyblN0b3JhZ2UxAKtBX0JhY2twYWNr\n    NAGpQV9TaG92ZWwxAKxBX05ldFdvcnRoMTIAq0FfTmV0V29ydGgyAahBX1Bsb3RzMwGjaW52\n    3AH0zyvVAAAAAAAAzxIZAAAAAAAAzy6EAAAAAAAAz3dkAAAAAAAAzwzZAAAAAAAAz2JRAAAA\n    AAAAzxnIAAAAAAAAz3lXAAAAAAAAzx2pAAAAAAAAzyP7AAAAAAAAz37rAAAAAAAAz1mOAAAA\n    AAAAzzeuAAAAAAAAzyW/AAAAAAAAzxSxAAAAAAAAzy3iAAAAAAAAz3pUAAAAAAAAzx7yAAAA\n    AAAAzwqgAAAAAAAAz3+2AAAAAAAAzxOVAAAAAAAAzzuZAAAAAAAAzzctAAAAAAAAzyoPAAAA\n    AAAAz1bMAAAAAAAAzyuhAAAAAAAAzwImAAAAAAAAzwDyAAAAAAAAzw25AAAAAAAAzxFdAAAA\n    AAAAzxdjAAAAAAAAzz3+AAAAAAAAzy/QAAAAAAAAz2tAAAAAAAAAzy2pAAAAAAAAz25KAAAA\n    AAAAz2vGAAAAAAAAz1TdAAAAAAAAz23eAAAAAAAAz12BAAAAAAAAzy9eAAAAAAAAzzscAAAA\n    AAAAz0Z0AAAAAAAAzzo8AAAAAAAAzxlxAAAAAAAAz1++AAAAAAAAzzcPAAAAAAAAz2+fAAAA\n    AAAAzwI9AAAAAAAAz0gTAAAAAAAAz2B5AAAAAAAAz3A3AAAAAAAAzwXvAAAAAAAAz3L6AAAA\n    AAAAz2TIAAAAAAAAz24TAAAAAAAAzz1zAAAAAAAAz3IaAAAAAAAAz2POAAAAAAAAzzwhAAAA\n    AAAAzxF7AAAAAAAAz0JgAAAAAAAAzx/CAAAAAAAAz1TMAAAAAAAAz1PNAAAAAAAAz3+5AAAA\n    AAAAzxYsAAAAAAAAz0HTAAAAAAAAzwrSAAAAAAAAz1AQAAAAAAAAzxkWAAAAAAAAz2FsAAAA\n    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\n    b24A\n]]\n\nreturn m"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 4002058138349424369
      Name: "easyStorage_README"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n                        ______\n     ___ ___ ____ __ __/ __/ /____  _______ ____ ____\n    / -_) _ `(_-</ // /\\ \\/ __/ _ \\/ __/ _ `/ _ `/ -_)\n    \\__/\\_,_/___/\\_, /___/\\__/\\___/_/  \\_,_/\\_, /\\__/\n               /___/                      /___/\n    easyStorage by zoonior\n\n    Copyright (c) 2021 Andrew Zhilin (https://github.com/zoon).\n    Core user: zoonior https://www.coregames.com/user/eec0239c0d644f5bb9f59779307edb17\n\n    == easyStorage\n    * very fast: less then 10ms for 32K data, you can update storage very often if needed\n      with no impact on performance\n    * convenient: only 4 methods that mimic Core Storage API\n    * automatically uses lzw compression when suitable\n\n    == To use easyStorage\n    1.  Drag the @easyStorage template and place it on the very top of your\n        scene hierarchy.\n    2.  Load the easyStorageAPI module:\n        ```lua\n            _ENV.require = _G.import or require\n            local easyStorageAPI = require(\"easyStorageAPI\")\n        ```\n        But you can use the vanilla Core \'require\':\n        ```lua\n            local easyStorageAPI = require(\"895FB503000AFB3E:easyStorageAPI\")\n        ```\n    3.  If you plan to use Shared Storage, fill in the custom property SHARED_STORAGE_KEY\n        at the hierarchy root object of @easyStorage instance\n        with the NetReference shared storage that you are going to use in your project.\n    4.  For Storage use methods (server only):\n        `easyStorageAPI.GetStorageData(player)`\n        `easyStorageAPI.SetStorageData(player, data)`\n    5.  For Shared Storage use methods (server only):\n        easyStorageAPI.GetSharedPlayerData(player)\n        easyStorageAPI.SetSharedPlayerData(player, data)\n    (!) Note that GetStorageData and GetSharedPlayerData return two values: data and data version.\n        The current data version can be set as a custom property STORAGE_VERSION\n        and SHARED_STORAGE_VERSION at the hierarchy root object of @easyStorage instance.\n    6.  For additional convenience there are 2 additional methods:\n        `easyStorageAPI.CompressData(data, toBase64)`\n        `easyStorageAPI:DecompressData(compressedData, fromBase64)`\n        You can use them to compress/decompress multiple lua and Core types (or nested tables of them):\n             * All lua types (including numerics: uint64, double etc.)\n             * Vector2/3/4\n             * Color\n             * Rotation\n             * Player\n             * CoreObjectReference\n    (!) Current limitation of CompressData is that it will only use lzw compression on the objects\n        that are less than 4KB after binary serialization. The main reason for that is not the\n        performance, but Core\'s limitation on Lua instruction count.\n        But even without compression, serialization format is very compact (internally it uses\n        MessagePack https://msgpack.org/).\n]]\n\n--[[ == easyStorage Runnable Example Block\n-- ------------------------------------------------------------------------------------------------\n-- To run it:\n\n-- 1.  Drag the @easyStorage template and place it on the very top of your\n--    scene hierarchy.\n\n-- 2. Put 2 instances of this script in game hierarchy: place one into the\n--    Client context, and another into the Default or Server context.\n\n-- 3. Uncomment this block (add the 3-rd dash: `---[[ == easyStorage Runnable ...)`.\n-- ------------------------------------------------------------------------------------------------\n_ENV.require = _G.import or require\nlocal easyStorageAPI = require(\"easyStorageAPI\")\n\nprint(\"\\n%%% easyStorage Runnable Example %%%\\n\")\n\n------------\n-- DATA\n------------\nlocal DataExample = require(script:GetCustomProperty(\"DataExample\"))\n-- the save file from Farmers Market ^_^\n-- CyberChief view of this data: https://tinyurl.com/rs8am5bd\nlocal FM_DATA_TABLE = easyStorageAPI.DecompressData(DataExample.FM_DATA, true)\n\n\nlocal function OnPlayerJoined(player)\n    local data = easyStorageAPI.GetPlayerData(player)\n    if not data[easyStorageAPI.VERSION_KEY] then\n        -- player has no saved state\n        local ok = easyStorageAPI.SetPlayerData(player, FM_DATA_TABLE)\n        assert(ok == StorageResultCode.SUCCESS)\n    end\n\n    Task.Wait(1)\n\n    local saved_data, version = easyStorageAPI.GetPlayerData(player)\n    assert(version == easyStorageAPI.STORAGE_VERSION, version)\n    for k, v in pairs(saved_data.inventory) do\n        -- do something with data like print(k, v) ^_^\n    end\n\n    Task.Wait(1)\n\n    --------------------\n    -- Size comparison\n    --------------------\n    -- Storage size as-is:\n    local storage_size = Storage.SizeOfData(FM_DATA_TABLE)\n    local compressed_base64 = easyStorageAPI.CompressData(FM_DATA_TABLE, true)\n    -- Storage size after compression and base64 encoding:\n    local compressed_storage_size = Storage.SizeOfData({compressed_base64})\n    print(\"Storage size of the Farmers Market save file BEFORE compression:\", storage_size)\n    print(\"Storage size of the Farmers Market save file AFTER compression:\", compressed_storage_size)\n    -- output:\n    -- Storage size of the Farmers Market save file BEFORE compression\t6112\n    -- Storage size of the Farmers Market save file AFTER compression\t2692\n\n    -- NB. 6112 vs 2692 (R=2.27) is a very good result for real-world data\n\nend\n\nGame.playerJoinedEvent:Connect(OnPlayerJoined)\n--]] -- end of runnable example block\n"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 10904663549924109574
      Name: "InitModules"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    _G.import: replacing Core `require` which can take the filename or MUID as\n    an argument. This is convenient since you no longer need to do custom\n    properties or hardcode MUID strings to export a module.\n\n    If you make `require` an alias of `_G.import` and export modules by name,\n    then they will continue to function correctly in the absence of Core - for\n    example, you can run tests in vanilla Lua 5.3, and not just in the editor.\n\n    ```lua\n    -- begining of the script\n    _ENV.require = _G.import or require\n\n    ```\n    (!) Server-only modules with conteiner in Server Context, will load\n    *after* Default modules. Consider some form of lazy import.\n\n    TODO: server-context modules loaded out of order\n    WORKAROUND: no server-context modules, require them by muid\n\n    TODO: FAQ\n    - How to make \"Module Container\" by yourself.\n    - How to prohibit an export of server-only modules in client context.\n    - Where to place module containers in hierarchy.\n    - Can I store templates in Module container and get them by name.\n]]\n\nlocal DEBUG = false\n\nlocal format = string.format\nlocal require = require\nlocal pcall = pcall\n\nlocal function protected_require(id)\n    local ok, result = pcall(require, id)\n    if not ok then\n        error(result, 3)\n    else\n        return result\n    end\nend\n\n-- This script must always be a child of Deafult and Client contexts of the root container.\nlocal CONTAINER = script.parent.parent\nlocal CONTEXT = CONTAINER.isServerOnly and \"SCTX:\" or \"\"\nlocal SERVER_OR_CLIENT = CONTEXT .. (Environment.IsClient() and \"Client\" or \"Server\")\n\nlocal MUID_DB_G_KEY = \"<~ Muid Db ~>\"\n\n_G[MUID_DB_G_KEY] = _G[MUID_DB_G_KEY] or {}\nlocal MUID_DB = _G[MUID_DB_G_KEY]\n\nfor name, muid in pairs(CONTAINER:GetCustomProperties()) do\n    if MUID_DB[name] then\n        error(string.format(\"ERROR: name duplication: `%s` in container `%s`\", name, CONTAINER.name), 2)\n    end\n    if DEBUG then\n        print(format(\"~~~> [%s] add module: %s\", SERVER_OR_CLIENT, name))\n    end\n    MUID_DB[name] = muid\nend\n\n-- get MUID by name\nlocal function get_muid(name)\n    local muid = MUID_DB[name]\n    if muid then\n        return muid\n    else\n        error(format(\"[%s]:ERROR: unknown muid for: `%s`\", SERVER_OR_CLIENT, name), 2)\n    end\nend\n\n-- register :: muid [, module_name] ^-> nil\nlocal function register(muid, name)\n    local id, script_name = CoreString.Split(muid, \':\')\n    if not muid and tonumber(id, 16) then\n        error(format(\"not a muid: \'%s\'\", muid), 2)\n    end\n    name = name or script_name\n    if not name then\n        error(format(\"no file name was provided\"))\n    end\n    MUID_DB[name] = muid\nend\n\n-- Replacement for Core\'s `require`, works with MUID, module name and AssetReference\n-- like vanilla Lua.\nlocal function import(id)\n    local muid = MUID_DB[id]\n    if not muid then\n        -- does it looks like MUID?\n        if type(id) == \"string\" and tonumber(CoreString.Split(id, \':\'), 16) then\n            return protected_require(id)\n        else\n            error(format(\"[%s]:ERROR: unknown module: \'%s\'\", SERVER_OR_CLIENT, id), 2)\n        end\n    end\n    local t1 = os.clock()\n    local module = protected_require(muid)\n    local dt = os.clock() - t1\n    if dt > 0.025 then\n        warn(format(\"[%s]: INFO: initial module loading time exceeds the 25 ms theshold: [%s]: %d ms.\",\n             SERVER_OR_CLIENT, id, dt*1000//1))\n    end\n    return module\nend\n\n-- export to global\n_G.get_muid = get_muid\n_G.import = import\n_G.register = register\n"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 225378120198817764
      Name: "LibLZW"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- Based on Go\'s compress/lzw package.\n\n-- Copyright (c) 2009-2021 The Go Authors. All rights reserved.\n\n-- Ported to Lua 5.3 by Andrew Zhilin (https://github.com/zoon).\n-- Copyright (c) 2021 Andrew Zhilin.\n\n-- Licensed under BSD 3-Clause License.\n\n-- Redistribution and use in source and binary forms, with or without\n-- modification, are permitted provided that the following conditions are\n-- met:\n--    * Redistributions of source code must retain the above copyright\n-- notice, this list of conditions and the following disclaimer.\n--    * Redistributions in binary form must reproduce the above\n-- copyright notice, this list of conditions and the following disclaimer\n-- in the documentation and/or other materials provided with the\n-- distribution.\n--    * Neither the name of Google Inc. nor the names of its\n-- contributors may be used to endorse or promote products derived from\n-- this software without specific prior written permission.\n-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-- \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n_ENV.require = _G.import or require\nlocal mp = require(\"MessagePack\")\nlocal b64 = require(\"QuickBase64\")\n\nlocal min, max = math.min, math.max\nlocal byte, char = string.byte, string.char\nlocal unpack, concat = table.unpack, table.concat\nlocal type, mtype = type, math.type\nlocal pcall = pcall\nlocal assert, error = assert, error\nlocal print, format = print, string.format\nlocal setmetatable = setmetatable\nlocal tonumber = tonumber\nlocal noop = function() end\n-- for test\nlocal rand, spack = math.random, string.pack\nlocal os = os\n-- Core\nlocal CORE_ENV = not not CoreDebug\nlocal Task = Task\nlocal warn = CORE_ENV and warn or noop\n_ENV = nil\n\n-----------------------------\n-- Module\n-----------------------------\n---@class lzw\n---@field LSB integer\n---@field MSB integer\n---@field Writer lzw.Writer\n---@field Reader lzw.Reader\nlocal m = {}\n\n-- TODO: export functions signatures\n-- TODO: optimize it! This implementation took ~15ms (with ratio: 1.637) on\n-- 17KB json_mp.bin, previous (all state in locals) took ~10ms.\n\n-- TODO: code style\n-- TODO: rename toRead to \"dst\"\n\n-----------------\n-- Const\n-----------------\n-- A code is a 12 bit value, stored as a uint32 when encoding to avoid\n--  type conversions when shifting bits.\nlocal maxCode = (1 << 12) - 1 -- 4095\nlocal invalidCode = (1 << 32) - 1 -- 0xffffffff\n-- There are 1<<12 possible codes, which is an upper bound on the number of\n-- valid hash table entries at any given point in time. tableSize is 4x that.\n-- TODO: use static table\nlocal tableSize = 4 * 1 << 12 -- 16348\nlocal tableMask = tableSize - 1\n-- A hash table entry is a uint32. Zero is an invalid entry since the\n-- lower 12 bits of a valid entry must be a non-literal code.\nlocal invalidEntry = 0\n\nlocal maxWidth = 12\nlocal decoderInvalidCode = 0xffff\nlocal flushBuffer = 1 << maxWidth\n\n\nlocal uninitialised = function()\n    error(\"uninitialised instance\")\nend\nlocal empty = setmetatable({}, {__index = uninitialised, __newindex = uninitialised})\n\n-- byte order\nlocal LSB = 1\nlocal MSB = 2\n\n\n-----------------------------\n-- Core utils\n-----------------------------\nlocal wait = CORE_ENV and Task.Wait or noop\n\n-----------------------------\n-- compress/decompress header\n-----------------------------\n-- For our format litWith always 8 bits, we get byte order from first *clear*\n-- byte.\nlocal LSB_LW8_CLEAR_BYTE = 0x00\nlocal MSB_LW8_CLEAR_BYTE = 0x80\n\n-- header prefix\nlocal HB0, HB1, HB2 = byte(\"lzw\", 1, 3)\n\nlocal function emit_header(writer)\n    assert(type(writer) == \"table\" and writer.type == \"lzw.Writer\")\n    local w = writer.w\n    w[#w + 1] = HB0\n    w[#w + 1] = HB1\n    w[#w + 1] = HB2\nend\n\n-- returns LSB | MSB | nil\nlocal function check_header(s)\n    local hb0, hb1, hb2, hb3 = byte(s, 1, 4)\n    if hb0 == HB0 and hb1 == HB1 and hb2 == HB2 then\n        if hb3 == LSB_LW8_CLEAR_BYTE then\n            return LSB\n        end\n        if hb3 == MSB_LW8_CLEAR_BYTE then\n            return MSB\n        end\n    end\nend\n\n-----------------------------\n-- Debug Utils\n-----------------------------\nlocal function hexify(s)\n    if mtype(s) == \"integer\" then\n        assert(s == s & 0xFF, \"argument should be a byte\")\n        if s > 31 and s < 127 then\n            return char(s)\n        end\n        return format(\"\\\\x%.2x\", s)\n    end\n    if (type(s) ~= \"string\") then\n        error(format(\"argument should be a string, got: \'%s\'\", type(s)))\n    end\n    local out = {}\n    for i = 1, #s do\n        out[#out + 1] = format(\"\\\\x%.2x\", byte(s, i))\n    end\n    if #out == 0 then\n        return \"\\\"\\\"\"\n    end\n    return concat(out)\nend\n\n-----------------------------\n-- Static arrays (lazy init)\n-----------------------------\n-- NB. total static memory allocation ~512KB\n-- for writer\nlocal _hashtable = nil -- size: 16384\nlocal function clear_hashtable()\n    if CORE_ENV then return {} end\n    if not _hashtable then\n        _hashtable = {}\n    end\n    local ht = _hashtable\n    for i = 0, tableSize - 1 do\n        ht[i] = invalidEntry\n    end\n    return ht\nend\n-- for reader\nlocal _suffix = nil -- size: 4095\nlocal _prefix = nil -- size: 4095\nlocal _output = nil -- size: 8191\n\nlocal function allocate_output()\n    -- we newer clear output, suffix and prefix\n    local alloc = not (_output and _suffix and _prefix)\n    if alloc then\n        _output = {}\n        _suffix = {}\n        _prefix = {}\n        if not _output then\n            _output = {}\n        end\n        for i = 0, (2 * 1 << maxWidth) - 1 do\n            _output[i] = 0\n        end\n        assert(#_output == (2 * 1 << maxWidth) - 1, #_output)\n        for i = 0, (1 << maxWidth) - 1 do\n            _suffix[i], _prefix[i] = 0, 0\n        end\n        assert(#_suffix == (1 * 1 << maxWidth) - 1)\n        assert(#_prefix == (1 * 1 << maxWidth) - 1)\n    end\n    return _output, _suffix, _prefix\nend\n\n-----------------------------\n--- Writer\n-----------------------------\nlocal Writer_mt = {}\nWriter_mt.__index = Writer_mt\n---@class lzw.Writer\nlocal Writer = setmetatable({type = \"lzw.Writer\"}, Writer_mt)\nWriter.__index = Writer\n\n-- TODO: cleanup go-style ctors\nlocal function newWriter(dst, order, litWidth)\n    assert(dst == nil or type(dst) == \"table\")\n    local w = Writer.new()\n    w:init(dst, order, litWidth)\n    return w\nend\n\n-- shortcut for constuctor\nfunction Writer_mt:__call(dst, order, litWidth)\n    return newWriter(dst, order, litWidth)\nend\n\n-- creates empty writer state\nfunction Writer.new()\n    return setmetatable({\n        -- w is the writer that compressed bytes are written to.\n        w = empty, -- writer\n        -- order, write, bits, nBits and width are the state for\n        -- converting a code stream into a byte stream.\n        order = LSB, -- Order\n        write = noop, -- func(*Writer, uint32) error\n        bits = 0, --  uint32\n        nBits = 0, -- uint\n        width = 0, -- uint\n        -- litWidth is the width in bits of literal codes.\n        litWidth = 0, -- uint\n        -- hi is the code implied by the next code emission.\n        -- overflow is the code at which hi overflows the code width.\n        hi = 0,\n        overflow = 0, -- uint32\n        -- savedCode is the accumulated code at the end of the most recent Write\n        -- call. It is equal to invalidCode if there was no such call.\n        savedCode = 0, -- uint32\n        -- err is the first error encountered during writing. Closing the writer\n        -- will make any future Write calls return errClosed\n        -- table is the hash table from 20-bit keys to 12-bit values. Each table\n        -- entry contains key<<12|val and collisions resolve by linear probing.\n        -- The keys consist of a 12-bit code prefix and an 8-bit byte suffix.\n        -- The values are a 12-bit code.\n        hashtable = empty -- [tableSize]uint32\n    }, Writer)\nend\n\nWriter.New = Writer.new\n\n-- all args optional\nfunction Writer:init(dst, order, litWidth)\n    local w = self\n    order = order or LSB\n    if order == LSB then\n        w.write = Writer.WriteLSB\n    elseif order == MSB then\n        w.write = Writer.WriteMSB\n    else\n        error(\"lzw: unknown order\")\n    end\n    litWidth = litWidth or 8\n    if litWidth < 2 or 8 < litWidth then\n        error(format(\"lzw: litWidth %d out of range\", litWidth))\n    end\n    w.w = dst or {}\n    w.order = order\n    w.width = 1 + litWidth\n    w.litWidth = litWidth\n    w.hi = (1 << litWidth) + 1\n    w.overflow = 1 << (litWidth + 1)\n    w.savedCode = invalidCode\n    -- reset or init table\n    w.hashtable = {} -- clear_hashtable()\n    return self\nend\n\n-- TODO: inline\nfunction Writer:WriteLSB(c)\n    local w = self\n    local ww = w.w\n    w.bits = w.bits | c << w.nBits\n    w.nBits = w.nBits + w.width\n    while w.nBits >= 8 do\n        -- NB. ww[#ww+1] = w.bits & 0xff took 2-4ms\n        ww[#ww + 1] = w.bits & 0xff\n        w.bits = w.bits >> 8\n        w.nBits = w.nBits - 8\n    end\nend\n\n-- NB. do not optimize it, let it be ref. for perf comparison\nfunction Writer:WriteMSB(c)\n    local w = self\n    w.bits = w.bits | c << (32 - w.width - w.nBits)\n    w.nBits = w.nBits + w.width\n    while w.nBits >= 8 do\n        w.w[#w.w + 1] = w.bits >> 24 & 0xff\n        w.bits = w.bits << 8\n        w.nBits = w.nBits - 8\n    end\nend\n\nfunction Writer:incHi()\n    local w = self\n    w.hi = w.hi + 1\n    if w.hi == w.overflow then\n        w.width = w.width + 1\n        w.overflow = w.overflow << 1\n    end\n    if w.hi == maxCode then\n        local clear = 1 << w.litWidth\n        w:write(clear)\n        w.width = w.litWidth + 1\n        w.hi = clear + 1\n        w.overflow = clear << 1\n        w.hashtable = clear_hashtable()\n        return true -- errOutOfCodes\n    end\nend\n\n-- Write writes a compressed representation of p to w\'s underlying writer.\nfunction Writer:Write(str, from, to)\n    assert(type(str) == \"string\", \"p must be a string\")\n    from = from or 1\n    to = to or #str\n    local len = to - from + 1\n    if len <= 0 then\n        return 0\n    end\n    local w = self\n    local maxLit = (1 << w.litWidth) - 1\n    if maxLit ~= 0xff then\n        for i = from, to do\n            local x = byte(str, i)\n            if x > maxLit then\n                error(format(\"lzw: input byte too large for the litWidth: %d\", w.litWidth))\n            end\n        end\n    end\n    local code = w.savedCode\n    if code == invalidCode then\n        -- This is the first write; send a clear code.\n        -- https://www.w3.org/Graphics/GIF/spec-gif89a.txt Appendix F\n        -- \"Variable-Length-Code LZW Compression\" says that \"Encoders should\n        -- output a Clear code as the first code of each image data stream\".\n        -- LZW compression isn\'t only used by GIF, but it\'s cheap to follow\n        -- that directive unconditionally.\n        local clear = 1 << w.litWidth\n        w:write(clear)\n        -- After the starting clear code, the next code sent (for non-empty\n        -- input) is always a literal code.\n        code = byte(str, from)\n        from = from + 1\n    end\n    ::loop::\n    assert(code)\n    for i = from, to do\n        local literal = byte(str, i)\n        local key = (code << 8) | literal\n        -- If there is a hash table hit for this key then we continue the loop\n        -- and do not emit a code yet.\n        local hash = (key >> 12) ~ key & tableMask\n        local h, t = hash, w.hashtable[hash]\n        -- if we don\'t use static ta\n        while t and t ~= invalidEntry do\n            if key == (t >> 12) then\n                code = t & maxCode\n                from = i + 1\n                goto loop\n            end\n            h = (h + 1) & tableMask\n            t = w.hashtable[h]\n        end\n        -- Otherwise, write the current code, and literal becomes the start of\n        -- the next emitted code.\n        w:write(code)\n        code = assert(literal)\n        -- Increment w.hi, the next implied code. If we run out of codes, reset\n        -- the writer state (including clearing the hash table) and continue.\n        if w:incHi() then\n            goto continue\n        end\n        while true do\n            if not w.hashtable[hash] or w.hashtable[hash] == invalidEntry then\n                w.hashtable[hash] = (key << 12) | w.hi\n                break\n            end\n            hash = (hash + 1) & tableMask\n        end\n        ::continue::\n    end\n    w.savedCode = code\n    return len\nend\n\nfunction Writer:Close(str)\n    local w = self\n    -- Write the savedCode if valid.\n    if w.savedCode ~= invalidCode then\n        w:write(w.savedCode)\n        w:incHi()\n    else\n        -- Write the starting clear code, as w.Write did not.\n        local clear = 1 << w.litWidth\n        w:write(clear)\n    end\n    -- Write the eof code.\n    local eof = (1 << w.litWidth) + 1\n    w:write(eof)\n    --  Write the final bits.\n    if w.nBits > 0 then\n        if w.order == MSB then\n            w.bits = w.bits >> 24\n        end\n        w.w[#w.w + 1] = w.bits & 0xff\n    end\n    return str and char(unpack(w.w)) or w.w\nend\n\nfunction Writer:Reset(dst, order, litWidth)\n    order = order or self.order\n    litWidth = litWidth or self.litWidth\n    self.bits = 0\n    self.nBits = 0\n    self.width = 0\n    self:init(dst, order, litWidth)\n    return self\nend\n\n-----------------------------\n-- Reader\n-----------------------------\nlocal Reader_mt = {}\nReader_mt.__index = Reader_mt\n\n---@class lzw.Reader\nlocal Reader = setmetatable({type = \"lzw.Reader\"}, Reader_mt)\nReader.__index = Reader\n\nfunction Reader.new()\n    return setmetatable({\n        r = nil, -- io.ByteReader\n        rFrom = 0, -- index for reader\n        rTo = 0, -- last byte index\n\n        bits = 0, -- uint32\n        nBits = 0, -- uint\n        width = 0, -- uint\n        read = noop, -- func(*Reader) (uint16, error) readLSB or readMSB\n        litWidth = 0, -- int, width in bits of literal codes\n        -- // The first 1<<litWidth codes are literal codes.\n        -- // The next two codes mean clear and EOF.\n        -- // Other valid codes are in the range [lo, hi] where lo := clear + 2,\n        -- // with the upper bound incrementing on each code seen.\n        -- //\n        -- // overflow is the code at which hi overflows the code width. It always\n        -- // equals 1 << width.\n        -- //\n        -- // last is the most recently seen code, or decoderInvalidCode.\n        -- //\n        -- // An invariant is that hi < overflow.\n        clear = 0,\n        eof = 0,\n        hi = 0,\n        overflow = 0,\n        last = 0, -- uint16 = 0\n\n        -- // Each code c in [lo, hi] expands to two or more bytes. For c != hi:\n        -- //   suffix[c] is the last of these bytes.\n        -- //   prefix[c] is the code for all but the last byte.\n        -- //   This code can either be a literal code or another code in [lo, c).\n        -- // The c == hi case is a special case.\n        suffix = empty, -- [1 << maxWidth]uint8 #4096\n        prefix = empty, -- [1 << maxWidth]uint16 #4096\n        -- // output is the temporary output buffer.\n        -- // Literal codes are accumulated from the start of the buffer.\n        -- // Non-literal codes decode to a sequence of suffixes that are first\n        -- // written right-to-left from the end of the buffer before being copied\n        -- // to the start of the buffer.\n        -- // It is flushed when it contains >= 1<<maxWidth bytes,\n        -- // so that there is always room to decode an entire code.\n        output = empty, -- [2 * 1 << maxWidth]byte 2*4096\n\n        o = 0, -- int    // write index into output\n        toRead = empty -- []byte // bytes to return from Read\n    }, Reader)\nend\n\nfunction Reader_mt:__call(src, from, to, order, litWidth, dst)\n    return self:newReader(src, from, to, order, litWidth, dst)\nend\n\nfunction Reader:newReader(src, from, to, order, litWidth, dst)\n    local r = Reader.new()\n    r:init(src, from, to, order, litWidth, dst)\n    return r\nend\n\nfunction Reader:Reset(src, from, to, order, litWidth, dst)\n    local r = self\n    r.bits = 0\n    r.nBits = 0\n    r.o = 0\n    r:init(src, from, to, order, litWidth, dst)\nend\n-- all args optional\nfunction Reader:init(src, from, to, order, litWidth, dst)\n    assert(src, \"Reader must be initialized with compressed string\")\n    local r = self\n    r.r = src\n    from = from or 1\n    to = to or #r.r\n    r.rFrom = from\n    r.rTo = to\n\n    local o, s, p = allocate_output()\n    r.output = o\n    r.suffix = s\n    r.prefix = p\n\n    order = order or LSB\n    if order == LSB then\n        r.read = Reader.ReadLSB\n    elseif order == MSB then\n        r.read = Reader.ReadMSB\n    else\n        error(\"lzw: unknown order \")\n    end\n\n    litWidth = litWidth or 8\n    if litWidth < 2 or 8 < litWidth then\n        error(format(\"lzw: litWidth %d out of range\", litWidth))\n    end\n    r.litWidth = litWidth\n    r.width = 1 + litWidth\n    r.clear = 1 << litWidth & 0xffff\n    r.eof, r.hi = r.clear + 1, r.clear + 1\n    r.overflow = 1 << r.width & 0xffff\n    r.last = decoderInvalidCode\n    r.toRead = dst or {} -- array to copy output to, i.e. user output\nend\n\nfunction Reader:ReadLSB()\n    local r = self\n    assert(r.rFrom > 0)\n    while r.nBits < r.width do\n        -- read byte\n        if r.rFrom > r.rTo then\n            error(\"lzw - unexpected EOF\")\n        end\n        local x = byte(r.r, r.rFrom)\n        r.rFrom = r.rFrom + 1\n        r.bits = r.bits | x << r.nBits\n        r.nBits = r.nBits + 8\n    end\n    local code = (r.bits & (1 << r.width) - 1) & 0xffff\n    r.bits = r.bits >> r.width\n    r.nBits = r.nBits - r.width\n    return code\nend\n\nfunction Reader:ReadMSB()\n    local r = self\n    while r.nBits < r.width do\n        -- read byte\n        if r.rFrom > r.rTo then\n            error(\"unexpected EOF\")\n        end\n        local x = byte(r.r, r.rFrom)\n        r.rFrom = r.rFrom + 1\n        r.bits = (r.bits | x << (24 - r.nBits)) & 0xffffffff\n        r.nBits = r.nBits + 8\n    end\n    local code = (r.bits >> (32 - r.width)) & 0xffff\n    r.bits = r.bits << r.width\n    r.nBits = r.nBits - r.width\n    return code\nend\n\n---@return boolean -- retuns true when decompression complete\nfunction Reader:Read()\n    local r = self\n    return r:decode()\nend\n\nfunction Reader:Close(str)\n    local r = self\n    local out = not str and r.toRead or char(unpack(r.toRead))\n    r.toRead = empty\n    return out\nend\n\nfunction Reader:decode()\n    local r = self\n    local eof = false\n    ::loop::\n    while true do\n        local code = r:read() -- ReadLSB | ReadMSB\n        -- classify codes\n        if code < r.clear then\n            -- we have a literal code\n            r.output[r.o] = code & 0xff\n            r.o = r.o + 1\n            if r.last ~= decoderInvalidCode then\n                -- Save what the hi code expands to.\n                r.suffix[r.hi] = code & 0xff\n                r.prefix[r.hi] = r.last\n            end\n        elseif code == r.clear then\n            r.width = 1 + r.litWidth\n            r.hi = r.eof\n            r.overflow = 1 << r.width\n            r.last = decoderInvalidCode\n            goto continue\n        elseif code == r.eof then\n            eof = true\n            break\n        elseif code <= r.hi then\n            -- output is 0-indexed\n            local c, i = code, #r.output -- len(r.output) - 1\n            if code == r.hi and r.last ~= decoderInvalidCode then\n                -- code == hi is a special case which expands to the last expansion\n                -- followed by the head of the last expansion. To find the head, we walk\n                -- the prefix chain until we find a literal code.\n                c = r.last\n                while c >= r.clear do\n                    c = r.prefix[c]\n                end\n                r.output[i] = c & 0xff\n                i = i - 1\n                c = r.last\n            end\n            -- Copy the suffix chain into output and then write that to w.\n            while c >= r.clear do\n                r.output[i] = r.suffix[c]\n                i = i - 1\n                c = r.prefix[c]\n            end\n            r.output[i] = c & 0xff\n            -- r.o += copy(r.output[r.o:], r.output[i:])\n            for oi = i, #r.output do\n                r.output[r.o] = r.output[oi]\n                r.o = r.o + 1\n            end\n            if r.last ~= decoderInvalidCode then\n                -- Save what the hi code expands to.\n                r.suffix[r.hi] = c & 0xff\n                r.prefix[r.hi] = r.last\n            end\n        else\n            error(\"lzw - invalid code\")\n        end -- if code ...\n        r.last, r.hi = code, r.hi + 1\n        if r.hi >= r.overflow then\n            if r.hi > r.overflow then\n                error(\"lzw - unreachable\")\n            end\n            if r.width == maxWidth then\n                r.last = decoderInvalidCode\n                -- Undo the d.hi++ a few lines above, so that (1) we maintain\n                -- the invariant that d.hi < d.overflow, and (2) d.hi does not\n                -- eventually overflow a uint16.\n                r.hi = r.hi - 1\n            else\n                r.width = r.width + 1\n                r.overflow = 1 << r.width\n            end\n        end\n        if r.o >= flushBuffer then\n            break\n        end\n        ::continue::\n    end -- loop\n    -- Flush pending output.\n    for oi = 0, r.o - 1 do\n        r.toRead[#r.toRead + 1] = r.output[oi]\n    end\n    r.o = 0\n    -- if r.rFrom < r.rTo then\n    --     goto loop\n    -- end\n    return eof\nend\n\n-----------------------------\n-- Test\n-----------------------------\n-- returns lw, order, tag\nlocal function split(s)\n    assert(type(s) == \"string\" and #s > 7)\n    local lw = tonumber(s:sub(-1))\n    local order = s:sub(-5, -3)\n    return lw, order == \"LSB\" and LSB or MSB, s:sub(1, -7)\nend\n\n-- LuaFormatter off\nlocal TEST_DATA = {\n    { -- 1\n        \"empty;LSB;7\",\n        \"\",\n        \"\\x80\\x81\",\n        nil\n    },\n    {\n        \"nonempty;LSB;7\",\n        \"Hi\",\n        \"\\x80Hi\\x81\",\n        nil\n    },\n    {\n        \"empty;LSB;8\",\n        \"\",\n        \"\\x00\\x03\\x02\",\n        nil,\n    },\n    {\n        \"empty;MSB;7\",\n        \"\",\n        \"\\x80\\x81\",\n        nil,\n    },\n    { -- 5\n        \"empty;MSB;8\",\n        \"\",\n        \"\\x80@@\",\n        nil,\n    },\n    {\n        \"tobe;LSB;7\",\n        \"TOBEORNOTTOBEORTOBEORNOT\",\n        \"\\x80TOBEORNOT\\x82\\x84\\x86\\x8b\\x85\\x87\\x89\\x81\",\n        nil,\n    },\n    {\n        \"tobe;LSB;8\",\n        \"TOBEORNOTTOBEORTOBEORNOT\",\n        \"\\x00\\xa9<\\x11R\\xe4\\x89\\x14\'O\\xa8\\b$hpa\\xc1\\x83\\t\\x03\\x02\",\n        nil,\n    },\n    {\n        \"tobe;MSB;7\",\n        \"TOBEORNOTTOBEORTOBEORNOT\",\n        \"\\x80TOBEORNOT\\x82\\x84\\x86\\x8b\\x85\\x87\\x89\\x81\",\n        nil,\n    },\n    {\n        \"tobe;MSB;8\",\n        \"TOBEORNOTTOBEORTOBEORNOT\",\n        \"\\x80\\x15\\t\\xe4\\\")<\\xa4N\'\\x95 PH4.\\v\\a\\x84\\xc0@\",\n        nil,\n    },\n    -- This example comes from https://en.wikipedia.org/wiki/Graphics_Interchange_Format.\n    { -- 10\n        \"gif;LSB;8\",\n        \"\\x28\\xff\\xff\\xff\\x28\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\",\n        \"\\x00\\x51\\xfc\\x1b\\x28\\x70\\xa0\\xc1\\x83\\x01\\x01\",\n        nil,\n    },\n    -- This example comes from http://compgroups.net/comp.lang.ruby/Decompressing-LZW-compression-from-PDF-file\n    {\n        \"pdf;MSB;8\",\n        \"-----A---B\",\n        \"\\x80\\x0b\\x60\\x50\\x22\\x0c\\x0c\\x85\\x01\",\n        nil,\n    },\n}\n-- LuaFormatter on\n\nlocal function internals_test()\n\n    -- write return test\n    local w = newWriter({}, LSB, 8)\n    local n = w:Write(\"asdf\")\n    assert(n == 4)\n    local s1 = char(unpack(w.w))\n    w:Reset()\n    n = w:Write(\"asdf\")\n    local s2 = char(unpack(w.w))\n    assert(n == 4)\n    assert(s1 == s2)\n\n    -- from-to test\n    local s = \"123TOBEORNOTTOBEORTOBEORNOT123\"\n    w:Reset(nil, LSB, 7)\n    n = w:Write(s, 1 + 3, #s - 3)\n    assert(n == #s - 3 - 3)\n    do\n        local got = w:Close(\"string\")\n        local compressed = \"\\x80TOBEORNOT\\x82\\x84\\x86\\x8b\\x85\\x87\\x89\\x81\"\n        if got ~= compressed then\n            error(format(\"FAIL mismatch result for \'%s\'\\n -> got: %s\\n expect: %s\", \"from-to;LSB;7\",\n                hexify(got), hexify(compressed)))\n        end\n    end\n\n    -- Writer test\n    for i = 1, #TEST_DATA do\n        local tt = TEST_DATA[i]\n        local desc, raw, compressed, err = tt[1], tt[2], tt[3], tt[4]\n        local lw, order, tag = split(desc)\n        w:Reset(nil, order, lw)\n        w:Write(raw)\n        local got = w:Close(\"string\")\n        if got ~= compressed then\n            error(format(\"FAIL(Writer#%d) mismatch result for \'%s\'\\ngot:    %s\\nexpect: %s\",\n                i, tt[1], hexify(got), hexify(compressed)))\n        elseif false then\n            print(\"[OK]\", \"Writer test\", tag)\n        end\n    end\n\n    -- Reader test\n    local r = Reader(\"\")\n    for i = 1, #TEST_DATA do\n        local tt = TEST_DATA[i]\n        local desc, raw, compressed, err = tt[1], tt[2], tt[3], tt[4]\n        local lw, order, tag = split(desc)\n        r:Reset(compressed, nil, nil, order, lw)\n        while not r:Read() do\n            -- read chanks\n        end\n        local got = r:Close(\"string\")\n        assert(got ~= nil)\n        if got ~= raw then\n            error(format(\"FAIL(Reader#%d) mismatch result for \'%s\'\\ngot:    %s\\nexpect: %s\",\n                i, tt[1], hexify(got), hexify(compressed)))\n        elseif false then\n            print(\"[OK]\", i, \"Reader test\", tag)\n        end\n    end\nend\n\nlocal function compress_test()\n    for i = 1, #TEST_DATA do\n        local tt = TEST_DATA[i]\n        local desc, raw = tt[1], tt[2]\n        local c = m.compress(raw)\n        local u = m.decompress(c)\n        assert(raw == u, desc)\n        c = m.compress(raw, nil, nil, MSB)\n        u = m.decompress(c)\n        assert(raw == u, desc)\n    end\nend\n\nlocal function chank_test()\n    local raws = {}\n    for i=1, #TEST_DATA do\n        raws[i] = TEST_DATA[i][2]\n    end\n    local data = concat(raws)\n    local w = Writer()\n    for i=1, #raws do\n        w:Write(raws[i])\n    end\n    local c = w:Close(\"str\")\n    local r = Reader(c)\n    while not r:Read() do end\n    local u = r:Close(\"str\")\n    assert(u == data)\nend\n\n-----------------------------\n-- Export lzw\n-----------------------------\n-- lazy initialization\nlocal _comp_writer = nil\nlocal _comp_reader = nil\n\nm.Writer = Writer\nm.Reader = Reader\n\n\n---return\nm.compress = function(str, from, to, msb)\n    if str == m then\n        error(\"compress is a static method, consider remove \':\'\")\n    end\n    from = from or 1\n    to = to or #str\n    local n = to - from + 1\n    -- NB. this is the result of Core instruction count limitation (~10K). lzw\n    -- can split compression to several frames, but it\'s impractical for\n    -- working with Storage. Meybe I will change my mind about it.\n    if CORE_ENV and to - from > 4090 then\n        -- warn(format(\"compress: string too long: %.4gKB, max: 4KB\", (to - from)/1000))\n        return str, n, n, 1.0\n    end\n    if not _comp_writer then\n        _comp_writer = Writer()\n    end\n    local writer = _comp_writer\n    if not msb then\n        writer:Reset(nil, LSB, 8)\n    else\n        writer:Reset(nil, MSB, 8)\n    end\n    emit_header(writer)\n    n = writer:Write(str, from, to)\n    local z = writer:Close(true)\n    -- 3 digits after dot\n    local ratio = n / #z + 0.0005\n    ratio = ratio - ratio % .001\n    return z, n, #z, ratio\nend\n\n-- if str do not begin with \'lzw\\0x00\' or \'lzw\\0x80\' then pass it throw.\nm.decompress = function(lzw_string)\n    if lzw_string == m then\n        error(\"decompress is a static method, consider remove \':\'\")\n    end\n    local order = check_header(lzw_string)\n    -- i.e. string not compressed at all, pass verbatim\n    if not order then\n        return lzw_string\n    end\n    assert(order == LSB or order == MSB, \"lzw - unknown byte order\")\n    if not _comp_reader then\n        _comp_reader = Reader(\"\")\n    end\n    local reader = _comp_reader\n    -- skip 3 byte of header (but not \'clear\')\n    if order == LSB then\n        reader:Reset(lzw_string, 4, nil, LSB, 8)\n    else\n        reader:Reset(lzw_string, 4, nil, MSB, 8)\n    end\n    local ok, result = pcall(function()\n        while not reader:Read() do\n            if CORE_ENV then\n                wait() -- 4KB per frame\n            end\n        end\n        return reader:Close(true)\n    end)\n    if not ok then\n        error(result)\n    end\n    return result\nend\n\nlocal function data64K_test()\n    local data = {}\n    for _ = 1, (1 << 16) / 8 do\n        data[#data + 1] = spack(\"d\", rand())\n    end\n    data = concat(data)\n    local c, x, y, z = m.compress(data)\n    -- print(\"compress 64K\", x, y, z)\n    local u = m.decompress(c)\n    assert(u == data)\nend\n\nlocal function data4K_test()\n    local data = {}\n    for _ = 1, (1 << 12) / 8 - 6 do\n        data[#data + 1] = spack(\"d\", rand())\n    end\n    data = concat(data)\n    local t1 = os.clock()\n    local c, x, y, z = m.compress(data)\n    local t2 = os.clock()\n    -- print(\"compress 4K\", x, y, z)\n    local u = m.decompress(c)\n    local t3 = os.clock()\n    -- print(\"4K compress\", t2 - t1, \"decompress\", t3 - t2)\n    assert(u == data)\nend\n\nlocal function run_test()\n        internals_test()\n        compress_test()\n        data64K_test()\n        data4K_test()\n        chank_test()\n    print(\"lzw -- ok\")\nend\n\nif not CORE_ENV then\n    run_test()\nelse\n    -- Task.Spawn(run_test, 1)\nend\n\nreturn m\n"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 7645259355759957035
      Name: "QuickBase64"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    Fast, memory conservative, pure Lua 5.3+ Base64 encoder/decoder.\r\n]]\r\n\r\n-- The MIT Licence (MIT)\r\n-- Copyright (c) 2021 Andrew Zhilin (https://github.com/zoon)\r\n\r\n---@class QuickBase64\r\nlocal m = {}\r\n\r\n-- Base64 alphabet: \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\'\r\n\r\nlocal char, byte, gsub, find = string.char, string.byte, string.gsub, string.find\r\nlocal pack, unpack, rep = string.pack, string.unpack, string.rep\r\nlocal concat, format = table.concat, string.format\r\nlocal type, assert, print, pairs, select = type, assert, print, pairs, select\r\nlocal ceil = math.ceil\r\nlocal error = error\r\n\r\n_ENV = nil\r\n\r\nlocal PAD = byte(\'=\')\r\n\r\n---------------------------------------\r\n-- Base64 encode\r\n---------------------------------------\r\n-- @ encode :: str -> str(base64)\r\nlocal encode do\r\n    local ENC = {[0]=\r\n        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\r\n        0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\r\n        0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\r\n        0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,\r\n        0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,\r\n        0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,\r\n        0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,\r\n        0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F,\r\n    }\r\n    -- pass data string to _enc\r\n    local _data = nil\r\n    -- caching lambda, it saves us ~100 bytes\r\n    -- unrolled for 36->48 chars, a little faster and gives 3-4x less garbage\r\n    local function _enc(x, y)\r\n        local data = _data -- pass data string to inner scope\r\n        -- 36 -> 48\r\n        if y - x == 36 then\r\n            local\r\n                a1, b1, c1, a2, b2, c2, a3, b3, c3,\r\n                a4, b4, c4, a5, b5, c5, a6, b6, c6,\r\n                a7, b7, c7, a8, b8, c8, a9, b9, c9,\r\n                aa, ba, ca, ab, bb, cb, ac, bc, cc = byte(data, x, x + 35)\r\n        return char(\r\n            ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63],\r\n            ENC[a2>>2], ENC[(a2&3)<<4|b2>>4], ENC[(b2&15)<<2|c2>>6], ENC[c2&63],\r\n            ENC[a3>>2], ENC[(a3&3)<<4|b3>>4], ENC[(b3&15)<<2|c3>>6], ENC[c3&63],\r\n            ENC[a4>>2], ENC[(a4&3)<<4|b4>>4], ENC[(b4&15)<<2|c4>>6], ENC[c4&63],\r\n            ENC[a5>>2], ENC[(a5&3)<<4|b5>>4], ENC[(b5&15)<<2|c5>>6], ENC[c5&63],\r\n            ENC[a6>>2], ENC[(a6&3)<<4|b6>>4], ENC[(b6&15)<<2|c6>>6], ENC[c6&63],\r\n            ENC[a7>>2], ENC[(a7&3)<<4|b7>>4], ENC[(b7&15)<<2|c7>>6], ENC[c7&63],\r\n            ENC[a8>>2], ENC[(a8&3)<<4|b8>>4], ENC[(b8&15)<<2|c8>>6], ENC[c8&63],\r\n            ENC[a9>>2], ENC[(a9&3)<<4|b9>>4], ENC[(b9&15)<<2|c9>>6], ENC[c9&63],\r\n            ENC[aa>>2], ENC[(aa&3)<<4|ba>>4], ENC[(ba&15)<<2|ca>>6], ENC[ca&63],\r\n            ENC[ab>>2], ENC[(ab&3)<<4|bb>>4], ENC[(bb&15)<<2|cb>>6], ENC[cb&63],\r\n            ENC[ac>>2], ENC[(ac&3)<<4|bc>>4], ENC[(bc&15)<<2|cc>>6], ENC[cc&63]\r\n        )\r\n        end\r\n\r\n        local out = {}\r\n        local a1, b1, c1, a2, b2, c2, a3, b3, c3\r\n        -- 9 -> 12\r\n        while x + 8 < y do\r\n            a1, b1, c1, a2, b2, c2, a3, b3, c3 = byte(data, x, x + 8)\r\n            out[#out+1] = char(\r\n                ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63],\r\n                ENC[a2>>2], ENC[(a2&3)<<4|b2>>4], ENC[(b2&15)<<2|c2>>6], ENC[c2&63],\r\n                ENC[a3>>2], ENC[(a3&3)<<4|b3>>4], ENC[(b3&15)<<2|c3>>6], ENC[c3&63]\r\n            )\r\n            x = x + 9\r\n        end\r\n        -- 3 -> 4\r\n        while x + 2 < y do\r\n            a1, b1, c1 = byte(data, x, x + 2)\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], ENC[c1&63])\r\n            x = x + 3\r\n        end\r\n        -- tail: 1..2 -> 2..3 + padding\r\n        local n = y - x\r\n        if n == 2 then\r\n            a1, b1 = byte(data, x, x + 1)\r\n            c1 = 0\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], ENC[(b1&15)<<2|c1>>6], PAD)\r\n        elseif n == 1 then\r\n            a1 = byte(data, x)\r\n            b1 = 0\r\n            out[#out+1] = char(ENC[a1>>2], ENC[(a1&3)<<4|b1>>4], PAD, PAD)\r\n        end\r\n        return concat(out)\r\n    end\r\n\r\n    -- there is no limiting quantifier support in lua patterns ...\r\n    local OPT36 = \"()\" .. rep(\'.?\', 36) .. \"()\"\r\n    encode = function(data)\r\n        _data = data -- pass data to outer scope\r\n        return (gsub(_data, OPT36, _enc)) -- coerce to one result\r\n    end\r\nend\r\n\r\n---------------------------------------\r\n-- Base64 decode\r\n---------------------------------------\r\n-- @ decode :: str(base64) -> str\r\nlocal decode do\r\n    local DEC = {\r\n        [0x41]=0x00, [0x42]=0x01, [0x43]=0x02, [0x44]=0x03, [0x45]=0x04, [0x46]=0x05, [0x47]=0x06, [0x48]=0x07,\r\n        [0x49]=0x08, [0x4A]=0x09, [0x4B]=0x0A, [0x4C]=0x0B, [0x4D]=0x0C, [0x4E]=0x0D, [0x4F]=0x0E, [0x50]=0x0F,\r\n        [0x51]=0x10, [0x52]=0x11, [0x53]=0x12, [0x54]=0x13, [0x55]=0x14, [0x56]=0x15, [0x57]=0x16, [0x58]=0x17,\r\n        [0x59]=0x18, [0x5A]=0x19, [0x61]=0x1A, [0x62]=0x1B, [0x63]=0x1C, [0x64]=0x1D, [0x65]=0x1E, [0x66]=0x1F,\r\n        [0x67]=0x20, [0x68]=0x21, [0x69]=0x22, [0x6A]=0x23, [0x6B]=0x24, [0x6C]=0x25, [0x6D]=0x26, [0x6E]=0x27,\r\n        [0x6F]=0x28, [0x70]=0x29, [0x71]=0x2A, [0x72]=0x2B, [0x73]=0x2C, [0x74]=0x2D, [0x75]=0x2E, [0x76]=0x2F,\r\n        [0x77]=0x30, [0x78]=0x31, [0x79]=0x32, [0x7A]=0x33, [0x30]=0x34, [0x31]=0x35, [0x32]=0x36, [0x33]=0x37,\r\n        [0x34]=0x38, [0x35]=0x39, [0x36]=0x3A, [0x37]=0x3B, [0x38]=0x3C, [0x39]=0x3D, [0x2B]=0x3E, [0x2F]=0x3F,\r\n    }\r\n\r\n    local _str64 = nil\r\n    -- caching lambda, it saves us ~100 bytes\r\n    -- unrolled for 48->36 chars, a little faster and gives 3-4x less garbage\r\n    local function _dec(x, y)\r\n        local b64str = _str64\r\n        -- 48 -> 36\r\n        if y - x == 48 and byte(b64str, x + 47) ~= PAD then\r\n            local\r\n                a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3,\r\n                a4, b4, c4, d4, a5, b5, c5, d5, a6, b6, c6, d6,\r\n                a7, b7, c7, d7, a8, b8, c8, d8, a9, b9, c9, d9,\r\n                aa, ba, ca, da, ab, bb, cb, db, ac, bc, cc, dc =\r\n                    byte(b64str, x, x + 47)\r\n                -- decode all\r\n                a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3,\r\n                a4, b4, c4, d4, a5, b5, c5, d5, a6, b6, c6, d6,\r\n                a7, b7, c7, d7, a8, b8, c8, d8, a9, b9, c9, d9,\r\n                aa, ba, ca, da, ab, bb, cb, db, ac, bc, cc, dc =\r\n                    DEC[a1], DEC[b1], DEC[c1], DEC[d1], DEC[a2], DEC[b2], DEC[c2], DEC[d2],\r\n                    DEC[a3], DEC[b3], DEC[c3], DEC[d3], DEC[a4], DEC[b4], DEC[c4], DEC[d4],\r\n                    DEC[a5], DEC[b5], DEC[c5], DEC[d5], DEC[a6], DEC[b6], DEC[c6], DEC[d6],\r\n                    DEC[a7], DEC[b7], DEC[c7], DEC[d7], DEC[a8], DEC[b8], DEC[c8], DEC[d8],\r\n                    DEC[a9], DEC[b9], DEC[c9], DEC[d9], DEC[aa], DEC[ba], DEC[ca], DEC[da],\r\n                    DEC[ab], DEC[bb], DEC[cb], DEC[db], DEC[ac], DEC[bc], DEC[cc], DEC[dc]\r\n            return char(\r\n                a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F,\r\n                a2<<2&0xFC|b2>>4&0x03, b2<<4&0xF0|c2>>2&0x0F, c2<<6&0xC0|d2>>0&0x3F,\r\n                a3<<2&0xFC|b3>>4&0x03, b3<<4&0xF0|c3>>2&0x0F, c3<<6&0xC0|d3>>0&0x3F,\r\n                a4<<2&0xFC|b4>>4&0x03, b4<<4&0xF0|c4>>2&0x0F, c4<<6&0xC0|d4>>0&0x3F,\r\n                a5<<2&0xFC|b5>>4&0x03, b5<<4&0xF0|c5>>2&0x0F, c5<<6&0xC0|d5>>0&0x3F,\r\n                a6<<2&0xFC|b6>>4&0x03, b6<<4&0xF0|c6>>2&0x0F, c6<<6&0xC0|d6>>0&0x3F,\r\n                a7<<2&0xFC|b7>>4&0x03, b7<<4&0xF0|c7>>2&0x0F, c7<<6&0xC0|d7>>0&0x3F,\r\n                a8<<2&0xFC|b8>>4&0x03, b8<<4&0xF0|c8>>2&0x0F, c8<<6&0xC0|d8>>0&0x3F,\r\n                a9<<2&0xFC|b9>>4&0x03, b9<<4&0xF0|c9>>2&0x0F, c9<<6&0xC0|d9>>0&0x3F,\r\n                aa<<2&0xFC|ba>>4&0x03, ba<<4&0xF0|ca>>2&0x0F, ca<<6&0xC0|da>>0&0x3F,\r\n                ab<<2&0xFC|bb>>4&0x03, bb<<4&0xF0|cb>>2&0x0F, cb<<6&0xC0|db>>0&0x3F,\r\n                ac<<2&0xFC|bc>>4&0x03, bc<<4&0xF0|cc>>2&0x0F, cc<<6&0xC0|dc>>0&0x3F\r\n            )\r\n        end\r\n\r\n        local out = {}\r\n        local a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3\r\n        -- 12 -> 9\r\n        while x + 11 < y - 4 do -- all but last 4\r\n            a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3 = byte(b64str, x, x + 11)\r\n            a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3 =\r\n                DEC[a1], DEC[b1], DEC[c1], DEC[d1], DEC[a2], DEC[b2],\r\n                DEC[c2], DEC[d2], DEC[a3], DEC[b3], DEC[c3], DEC[d3]\r\n            out[#out+1] = char(\r\n                a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F,\r\n                a2<<2&0xFC|b2>>4&0x03, b2<<4&0xF0|c2>>2&0x0F, c2<<6&0xC0|d2>>0&0x3F,\r\n                a3<<2&0xFC|b3>>4&0x03, b3<<4&0xF0|c3>>2&0x0F, c3<<6&0xC0|d3>>0&0x3F\r\n            )\r\n            x = x + 12\r\n        end\r\n        -- 4 -> 3\r\n        while x + 3 < y - 4 do -- all but last 4\r\n            a1, b1, c1, d1 = byte(b64str, x, x + 3)\r\n            a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F)\r\n            x = x + 4\r\n        end\r\n        -- last 4 -> 1..3\r\n        a1, b1, c1, d1 = byte(b64str, x, x + 3)\r\n        a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n        local n = c1 and d1 and 3 or c1 and 2 or 1\r\n        if n == 3 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F)\r\n        elseif n == 2 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F)\r\n        elseif n == 1 then\r\n            out[#out+1] = char(a1<<2&0xFC|b1>>4&0x03)\r\n        end\r\n        return concat(out)\r\n    end\r\n\r\n    local OPT48 = \"()\" .. rep(\'.?\', 48) .. \"()\"\r\n    decode = function (str64)\r\n        assert(type(str64) == \"string\", \"string expected\")\r\n        if #str64 == 0 then return \"\" end\r\n        -- remove whitespace if any (`find` then `gsub` much faster, if there is no whitespace)\r\n        if find(str64, \"%s+\") then str64 = gsub(str64, \"%s+\", \"\") end\r\n        assert(#str64%4 == 0, \"invalid encoding: input length is not divisible by 4\")\r\n        _str64 = str64 -- pass encoded string to outer scope\r\n        return (gsub(str64, OPT48, _dec)) -- coerce to one result\r\n    end\r\n\r\n    ----------------------------------\r\n    -- partial decode utils:\r\n    ----------------------------------\r\n    local function _test(prefix, ...)\r\n        assert(prefix and #prefix <= 3, \"length of prefix should be 1..3\")\r\n        assert(select(\"#\", ...) == 3)\r\n        for i = 1, #prefix do\r\n            if byte(prefix, i) ~= select(i, ...) then return false end\r\n        end\r\n        return true\r\n    end\r\n\r\n    -- @ dec3 :: str(base64) -> byte1, byte2, byte3\r\n    local function dec3(str64)\r\n        assert(str64 and #str64 >= 4, \"length of encoded string should be >= 4\")\r\n        local a1, b1, c1, d1 = byte(str64, 1, 4)\r\n        a1, b1, c1, d1 = DEC[a1], DEC[b1], DEC[c1], DEC[d1]\r\n        return a1<<2&0xFC|b1>>4&0x03, b1<<4&0xF0|c1>>2&0x0F, c1<<6&0xC0|d1>>0&0x3F\r\n    end\r\n\r\n    -- @ test_prefix :: str(base64), str -> bool\r\n    -- prefix :: str with length [1..3]\r\n    local function test_prefix(str64, prefix)\r\n        return _test(prefix, dec3(str64))\r\n    end\r\n\r\n    -- @ select_prefix :: str(base64), prefix1:str, prefix2:str, ...  -> index\r\n    -- prefix :: str with length [1..3]\r\n    local function select_prefix(str64, ...)\r\n        local n = select(\"#\", ...)\r\n        local b1, b2, b3 = dec3(str64)\r\n        for i = 1, n do\r\n            if _test(select(i, ...), b1, b2, b3) then return i end\r\n        end\r\n    end\r\n\r\n    -- exports\r\n    m.dec3 = dec3\r\n    m.test_prefix = test_prefix\r\n    m.select_prefix = select_prefix\r\nend\r\n\r\nlocal function _self_test()\r\n    local data = {\r\n        [\"\"] = \"\",\r\n        [\"A\"]=\"QQ==\",\r\n        [\"BC\"]=\"QkM=\",\r\n        [\"DEF\"]=\"REVG\",\r\n        [\"*?!@\"]=\"Kj8hQA==\",\r\n        [\"Man \"]=\"TWFuIA==\",\r\n        [\"7904 (base10)\"]=\"NzkwNCAoYmFzZTEwKQ==\",\r\n        [\"1337lEEt\\0\\0\\0\\0\"]=\"MTMzN2xFRXQAAAAA\",\r\n        [\"Use our super handy online tool to decode or encode your data.\"] =\r\n            \"VXNlIG91ciBzdXBlciBoYW5keSBvbmxpbmUgdG9vbCB0byBkZWNvZGUgb3IgZW5jb2RlIHlvdXIgZGF0YS4=\",\r\n        [\"<D\\254\"] = \"PET+\"\r\n    }\r\n    for r, e in pairs(data) do\r\n        assert(encode(r) == e, format(\"err encode: %q -> %q\", r, encode(r)))\r\n        assert(decode(e) == r, format(\"err decode: %q -> %q\", r, decode(e)))\r\n    end\r\n\r\n    local str64 = encode(\"7904 (base10)\")\r\n    assert(m.test_prefix(str64, \"7\"))\r\n    assert(m.test_prefix(str64, \"79\"))\r\n    assert(m.test_prefix(str64, \"790\"))\r\n    assert(m.select_prefix(str64, \"A\", \"BB\", \"790\", \"CCC\") == 3)\r\n\r\n    assert(m.test_prefix(\"REVG\", \"DEF\"))\r\n\r\n    -- bugfix (dec returns 2 values)\r\n    local id = \"eec0239c0d644f5bb9f59779307edb17\"\r\n    local fmt = \"c1 z c3\"\r\n    local x = pack(fmt, \"$\", id, \"C09\")\r\n    assert(select(2, unpack(fmt, x)) == id)\r\n    assert(select(2, unpack(fmt, decode(encode(x)))) == id)\r\n\r\n    --\r\n    print(\'base64 -- ok\')\r\nend\r\n\r\n_self_test()\r\n\r\n-- module exports\r\n\r\n---@param n integer\r\n---@param extra_bytes integer -- optional\r\n---@return integer\r\nlocal function encoded_size(n, extra_bytes)\r\n    extra_bytes = extra_bytes or 0\r\n    return 4 * ceil((n + extra_bytes) / 3)\r\nend\r\n\r\nm.encode = encode\r\nm.decode = decode\r\nm.encoded_size = encoded_size\r\n\r\nreturn m"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 7103355485084642100
      Name: "MessagePack"
      PlatformAssetType: 3
      TextAsset {
        Text: "---@diagnostic disable: undefined-field\n--\n-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>\n--\n--[[\n    lua-MessagePack (MP) Core extensions:\n\n    * An alias for MP.pack with *measure* option.\n      Returns MessagePack serialized string. With truthy `measure` option\n      returns the length of serialized string instead.\n    @ MP.encode :: data[, measure=nil]-> str(MP)\n\n    * An alias for MP.unpack with interval and \"no throw\" options. Returns\n      message pack encoded string or throw an error. The `no_throw` option\n      allows you to return `nil` instead of throwing an error.\n    @ MP.decode :: str(MP)[, from=1][, to=#str(MP)][, no_throw=nil] -> data\n\n    * Support for Core types (through MessagePack `ext`):\n        - CoreObjectReference (via CoreObjectReferenceProxy)\n        - Color\n        - Player\n        - Rotation\n        - Vector2\n        - Vector3\n        - Vector4\n    (!) By default, all non-integer Lua numbers will be serialized as a double (64-bit).\n        This option can be changed: `MP.set_number(\"float|double\")`\n        All Core\'s Vector-ish elements will be serialized as float 32.\n    (!) Whenever possible, you should use constants (like Color.WHITE or Vector3.ONE) -\n        they are much more efficient to serialize.\n\n    Usage (in Core):\n    ```\n        local mp = require(\"XXXXXXXX:MessagePack\") -- Core style MUID require\n\n        -- Feed it with any lua (no function, of course) or supported Core values:\n        local data = {tag = \"TestData\", Vector2.New(10, 20), Vector3.ONE, Color.CYAN}\n        local encoded = mp.encode(data)    -- => string 33 bytes\n        local decoded = mp.decode(encoded) -- => {tag=\"TestData\", Vector2(10, 20), Vector3.ONE, Color.CYAN}\n    ```\n\n    Core Extensions:\n    Copyright (c) 2021 Andrew Zhilin (https://github.com/zoon)\n\n    lua-MessagePack:\n    Copyright (c) 2012-2019 Francois Perrad\n\n]]\n-- luaFormatter off\n\nlocal assert = assert\nlocal error = error\nlocal pairs = pairs\nlocal pcall = pcall\nlocal setmetatable = setmetatable\nlocal tostring = tostring\nlocal type = type\nlocal char = string.char\nlocal format = string.format\nlocal math_type = math.type\nlocal tointeger = math.tointeger\nlocal tconcat = table.concat\nlocal pack = string.pack\nlocal unpack = string.unpack\nlocal tunpack = table.unpack\nlocal byte = string.byte\n\nlocal ipairs = ipairs\nlocal tonumber, print = tonumber, print\nlocal BIG_TIMEOUT = 120\n\n---------------------------------------\n-- Core types:\n---------------------------------------\nlocal CoreString = CoreString\nlocal CORE_ENV = CoreString and true\nlocal CoreDebug = CoreDebug\nlocal Color = Color\nlocal Rotation = Rotation\nlocal Vector2 = Vector2\nlocal Vector3 = Vector3\nlocal Vector4 = Vector4\nlocal Task = Task\nlocal Game = Game\nlocal World = World\nlocal time = time\n\n---------------------------------------\n-- User types:\n---------------------------------------\nlocal require = _G.import or require\n\n_ENV = nil\n\nlocal m = {}\n\n\n--[[ debug only\nlocal function hexadump (s)\n    return (s:gsub(\'.\', function (c) return format(\'%02X \', c:byte()) end))\nend\nm.hexadump = hexadump\n--]]\n\nlocal function argerror (caller, narg, extramsg)\n    error(\"bad argument #\" .. tostring(narg) .. \" to \"\n          .. caller .. \" (\" .. extramsg .. \")\")\nend\n\nlocal function typeerror (caller, narg, arg, tname)\n    argerror(caller, narg, tname .. \" expected, got \" .. type(arg))\nend\n\nlocal function checktype (caller, narg, arg, tname)\n    if type(arg) ~= tname then\n        typeerror(caller, narg, arg, tname)\n    end\nend\n\nlocal packers = setmetatable({}, {\n    __index = function (t, k)\n        if k == 1 then return end   -- allows ipairs\n        error(\"pack \'\" .. k .. \"\' is unimplemented\".. CoreDebug.GetStackTrace())\n    end\n})\nm.packers = packers\n\npackers[\'nil\'] = function (buffer)\n    buffer[#buffer+1] = char(0xC0)                      -- nil\nend\n\npackers[\'boolean\'] = function (buffer, bool)\n    if bool then\n        buffer[#buffer+1] = char(0xC3)                  -- true\n    else\n        buffer[#buffer+1] = char(0xC2)                  -- false\n    end\nend\n\npackers[\'string_compat\'] = function (buffer, str)\n    local n = #str\n    if n <= 0x1F then\n        buffer[#buffer+1] = char(0xA0 + n)              -- fixstr\n    elseif n <= 0xFFFF then\n        buffer[#buffer+1] = pack(\'>B I2\', 0xDA, n)      -- str16\n    elseif n <= 0xFFFFFFFF then\n        buffer[#buffer+1] = pack(\'>B I4\', 0xDB, n)      -- str32\n    else\n        error\"overflow in pack \'string_compat\'\"\n    end\n    buffer[#buffer+1] = str\nend\n\npackers[\'_string\'] = function (buffer, str)\n    local n = #str\n    if n <= 0x1F then\n        buffer[#buffer+1] = char(0xA0 + n)              -- fixstr\n    elseif n <= 0xFF then\n        buffer[#buffer+1] = char(0xD9, n)               -- str8\n    elseif n <= 0xFFFF then\n        buffer[#buffer+1] = pack(\'>B I2\', 0xDA, n)      -- str16\n    elseif n <= 0xFFFFFFFF then\n        buffer[#buffer+1] = pack(\'>B I4\', 0xDB, n)      -- str32\n    else\n        error\"overflow in pack \'string\'\"\n    end\n    buffer[#buffer+1] = str\nend\n\npackers[\'binary\'] = function (buffer, str)\n    local n = #str\n    if n <= 0xFF then\n        buffer[#buffer+1] = char(0xC4, n)               -- bin8\n    elseif n <= 0xFFFF then\n        buffer[#buffer+1] = pack(\'>B I2\', 0xC5, n)      -- bin16\n    elseif n <= 0xFFFFFFFF then\n        buffer[#buffer+1] = pack(\'>B I4\', 0xC6, n)      -- bin32\n    else\n        error\"overflow in pack \'binary\'\"\n    end\n    buffer[#buffer+1] = str\nend\n\nlocal set_string = function (str)\n    if str == \'string_compat\' then\n        packers[\'string\'] = packers[\'string_compat\']\n    elseif str == \'string\' then\n        packers[\'string\'] = packers[\'_string\']\n    elseif str == \'binary\' then\n        packers[\'string\'] = packers[\'binary\']\n    else\n        argerror(\'set_string\', 1, \"invalid option \'\" .. str ..\"\'\")\n    end\nend\nm.set_string = set_string\n\npackers[\'map\'] = function (buffer, tbl, n)\n    if n <= 0x0F then\n        buffer[#buffer+1] = char(0x80 + n)              -- fixmap\n    elseif n <= 0xFFFF then\n        buffer[#buffer+1] = pack(\'>B I2\', 0xDE, n)      -- map16\n    elseif n <= 0xFFFFFFFF then\n        buffer[#buffer+1] = pack(\'>B I4\', 0xDF, n)      -- map32\n    else\n        error\"overflow in pack \'map\'\"\n    end\n    for k, v in pairs(tbl) do\n        packers[type(k)](buffer, k)\n        packers[type(v)](buffer, v)\n    end\nend\n\npackers[\'array\'] = function (buffer, tbl, n)\n    if n <= 0x0F then\n        buffer[#buffer+1] = char(0x90 + n)              -- fixarray\n    elseif n <= 0xFFFF then\n        buffer[#buffer+1] = pack(\'>B I2\', 0xDC, n)      -- array16\n    elseif n <= 0xFFFFFFFF then\n        buffer[#buffer+1] = pack(\'>B I4\', 0xDD, n)      -- array32\n    else\n        error\"overflow in pack \'array\'\"\n    end\n    for i = 1, n do\n        local v = tbl[i]\n        packers[type(v)](buffer, v)\n    end\nend\n\nlocal set_array = function (array)\n    if array == \'without_hole\' then\n        packers[\'_table\'] = function (buffer, tbl)\n            local is_map, n, max = false, 0, 0\n            for k in pairs(tbl) do\n                if type(k) == \'number\' and k > 0 then\n                    if k > max then\n                        max = k\n                    end\n                else\n                    is_map = true\n                end\n                n = n + 1\n            end\n            if max ~= n then    -- there are holes\n                is_map = true\n            end\n            if is_map then\n                packers[\'map\'](buffer, tbl, n)\n            else\n                packers[\'array\'](buffer, tbl, n)\n            end\n        end\n    elseif array == \'with_hole\' then\n        packers[\'_table\'] = function (buffer, tbl)\n            local is_map, n, max = false, 0, 0\n            for k in pairs(tbl) do\n                if type(k) == \'number\' and k > 0 then\n                    if k > max then\n                        max = k\n                    end\n                else\n                    is_map = true\n                end\n                n = n + 1\n            end\n            if is_map then\n                packers[\'map\'](buffer, tbl, n)\n            else\n                packers[\'array\'](buffer, tbl, max)\n            end\n        end\n    elseif array == \'always_as_map\' then\n        packers[\'_table\'] = function(buffer, tbl)\n            local n = 0\n            for k in pairs(tbl) do\n                n = n + 1\n            end\n            packers[\'map\'](buffer, tbl, n)\n        end\n    else\n        argerror(\'set_array\', 1, \"invalid option \'\" .. array ..\"\'\")\n    end\nend\nm.set_array = set_array\n\n-- forward declaration\nlocal EXT_USER_ENCODERS = {}\n\npackers[\'table\'] = function (buffer, tbl)\n    if tbl.type and EXT_USER_ENCODERS[tbl.type] then\n        EXT_USER_ENCODERS[tbl.type](buffer, tbl)\n    else\n        if tbl.type then\n            -- print(\"@@\", tbl.type, #EXT_USER_ENCODERS)\n        end\n        packers[\'_table\'](buffer, tbl)\n    end\nend\n\npackers[\'unsigned\'] = function (buffer, n)\n    if n >= 0 then\n        if n <= 0x7F then\n            buffer[#buffer+1] = char(n)                 -- fixnum_pos\n        elseif n <= 0xFF then\n            buffer[#buffer+1] = char(0xCC, n)           -- uint8\n        elseif n <= 0xFFFF then\n            buffer[#buffer+1] = pack(\'>B I2\', 0xCD, n)  -- uint16\n        elseif n <= 0xFFFFFFFF then\n            buffer[#buffer+1] = pack(\'>B I4\', 0xCE, n)  -- uint32\n        else\n            buffer[#buffer+1] = pack(\'>B I8\', 0xCF, n)  -- uint64\n        end\n    else\n        if n >= -0x20 then\n            buffer[#buffer+1] = char(0x100 + n)         -- fixnum_neg\n        elseif n >= -0x80 then\n            buffer[#buffer+1] = pack(\'>B i1\', 0xD0, n)  -- int8\n        elseif n >= -0x8000 then\n            buffer[#buffer+1] = pack(\'>B i2\', 0xD1, n)  -- int16\n        elseif n >= -0x80000000 then\n            buffer[#buffer+1] = pack(\'>B i4\', 0xD2, n)  -- int32\n        else\n            buffer[#buffer+1] = pack(\'>B i8\', 0xD3, n)  -- int64\n        end\n    end\nend\n\npackers[\'signed\'] = function (buffer, n)\n    if n >= 0 then\n        if n <= 0x7F then\n            buffer[#buffer+1] = char(n)                 -- fixnum_pos\n        elseif n <= 0x7FFF then\n            buffer[#buffer+1] = pack(\'>B i2\', 0xD1, n)  -- int16\n        elseif n <= 0x7FFFFFFF then\n            buffer[#buffer+1] = pack(\'>B i4\', 0xD2, n)  -- int32\n        else\n            buffer[#buffer+1] = pack(\'>B i8\', 0xD3, n)  -- int64\n        end\n    else\n        if n >= -0x20 then\n            buffer[#buffer+1] = char(0xE0 + 0x20 + n)   -- fixnum_neg\n        elseif n >= -0x80 then\n            buffer[#buffer+1] = pack(\'>B i1\', 0xD0, n)  -- int8\n        elseif n >= -0x8000 then\n            buffer[#buffer+1] = pack(\'>B i2\', 0xD1, n)  -- int16\n        elseif n >= -0x80000000 then\n            buffer[#buffer+1] = pack(\'>B i4\', 0xD2, n)  -- int32\n        else\n            buffer[#buffer+1] = pack(\'>B i8\', 0xD3, n)  -- int64\n        end\n    end\nend\n\nlocal set_integer = function (integer)\n    if integer == \'unsigned\' then\n        packers[\'integer\'] = packers[\'unsigned\']\n    elseif integer == \'signed\' then\n        packers[\'integer\'] = packers[\'signed\']\n    else\n        argerror(\'set_integer\', 1, \"invalid option \'\" .. integer ..\"\'\")\n    end\nend\nm.set_integer = set_integer\n\npackers[\'float\'] = function (buffer, n)\n    buffer[#buffer+1] = pack(\'>B f\', 0xCA, n)\nend\n\npackers[\'double\'] = function (buffer, n)\n    buffer[#buffer+1] = pack(\'>B d\', 0xCB, n)\nend\n\nlocal set_number = function (number)\n    if number == \'float\' then\n        packers[\'number\'] = function (buffer, n)\n            if math_type(n) == \'integer\' then\n                packers[\'integer\'](buffer, n)\n            else\n                packers[\'float\'](buffer, n)\n            end\n        end\n    elseif number == \'double\' then\n        packers[\'number\'] = function (buffer, n)\n            if math_type(n) == \'integer\' then\n                packers[\'integer\'](buffer, n)\n            else\n                packers[\'double\'](buffer, n)\n            end\n        end\n    else\n        argerror(\'set_number\', 1, \"invalid option \'\" .. number ..\"\'\")\n    end\nend\nm.set_number = set_number\n\nfor k = 0, 4 do\n    local n = tointeger(2^k)\n    local fixext = 0xD4 + k\n    packers[\'fixext\' .. tostring(n)] = function (buffer, tag, data)\n        assert(#data == n, \"bad length for fixext\" .. tostring(n))\n        buffer[#buffer+1] = pack(\'>B i1\', fixext, tag)\n        buffer[#buffer+1] = data\n    end\nend\n\npackers[\'ext\'] = function (buffer, tag, data)\n    local n = #data\n    if n <= 0xFF then\n        buffer[#buffer+1] = pack(\'>B B i1\', 0xC7, n, tag)       -- ext8\n    elseif n <= 0xFFFF then\n        buffer[#buffer+1] = pack(\'>B I2 i1\', 0xC8, n, tag)      -- ext16\n    elseif n <= 0xFFFFFFFF then\n        buffer[#buffer+1] = pack(\'>B I4 i1\', 0xC9, n, tag)      -- ext32\n    else\n        error\"overflow in pack \'ext\'\"\n    end\n    buffer[#buffer+1] = data\nend\n\nfunction m.pack (data)\n    local buffer = {}\n    packers[type(data)](buffer, data)\n    return tconcat(buffer)\nend\n\nlocal unpackers         -- forward declaration\n\nlocal function unpack_cursor (c)\n    local s, i, j = c.s, c.i, c.j\n    if i > j then\n        c:underflow(i)\n        s, i, j = c.s, c.i, c.j\n    end\n    local val = s:byte(i)\n    c.i = i+1\n    return unpackers[val](c, val)\nend\nm.unpack_cursor = unpack_cursor\n\nlocal function unpack_str (c, n)\n    local s, i, j = c.s, c.i, c.j\n    local e = i+n-1\n    if e > j or n < 0 then\n        c:underflow(e)\n        s, i, j = c.s, c.i, c.j\n        e = i+n-1\n    end\n    c.i = i+n\n    return s:sub(i, e)\nend\n\nlocal function unpack_array (c, n)\n    local t = {}\n    for i = 1, n do\n        t[i] = unpack_cursor(c)\n    end\n    return t\nend\n\nlocal function unpack_map (c, n)\n    local t = {}\n    for i = 1, n do\n        local k = unpack_cursor(c)\n        local val = unpack_cursor(c)\n        if k == nil or k ~= k then\n            k = m.sentinel\n        end\n        if k ~= nil then\n            t[k] = val\n        end\n    end\n    return t\nend\n\nlocal function unpack_float (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+3 > j then\n        c:underflow(i+3)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+4\n    return unpack(\'>f\', s, i)\nend\n\nlocal function unpack_double (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+7 > j then\n        c:underflow(i+7)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+8\n    return unpack(\'>d\', s, i)\nend\n\nlocal function unpack_uint8 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i > j then\n        c:underflow(i)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+1\n    return unpack(\'>I1\', s, i)\nend\n\nlocal function unpack_uint16 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+1 > j then\n        c:underflow(i+1)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+2\n    return unpack(\'>I2\', s, i)\nend\n\nlocal function unpack_uint32 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+3 > j then\n        c:underflow(i+3)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+4\n    return unpack(\'>I4\', s, i)\nend\n\nlocal function unpack_uint64 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+7 > j then\n        c:underflow(i+7)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+8\n    return unpack(\'>I8\', s, i)\nend\n\nlocal function unpack_int8 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i > j then\n        c:underflow(i)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+1\n    return unpack(\'>i1\', s, i)\nend\n\nlocal function unpack_int16 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+1 > j then\n        c:underflow(i+1)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+2\n    return unpack(\'>i2\', s, i)\nend\n\nlocal function unpack_int32 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+3 > j then\n        c:underflow(i+3)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+4\n    return unpack(\'>i4\', s, i)\nend\n\nlocal function unpack_int64 (c)\n    local s, i, j = c.s, c.i, c.j\n    if i+7 > j then\n        c:underflow(i+7)\n        s, i, j = c.s, c.i, c.j\n    end\n    c.i = i+8\n    return unpack(\'>i8\', s, i)\nend\n\n-- we will define it lower ...\n-- function m.build_ext (tag, data)\n--     return nil\n-- end\n\nlocal function unpack_ext (c, n, tag)\n    local s, i, j = c.s, c.i, c.j\n    local e = i+n-1\n    if e > j or n < 0 then\n        c:underflow(e)\n        s, i, j = c.s, c.i, c.j\n        e = i+n-1\n    end\n    c.i = i+n\n    return m.build_ext(tag, s:sub(i, e))\nend\n\nunpackers = setmetatable({\n    [0xC0] = function () return nil end,\n    [0xC2] = function () return false end,\n    [0xC3] = function () return true end,\n    [0xC4] = function (c) return unpack_str(c, unpack_uint8(c)) end,    -- bin8\n    [0xC5] = function (c) return unpack_str(c, unpack_uint16(c)) end,   -- bin16\n    [0xC6] = function (c) return unpack_str(c, unpack_uint32(c)) end,   -- bin32\n    [0xC7] = function (c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,\n    [0xC8] = function (c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,\n    [0xC9] = function (c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,\n    [0xCA] = unpack_float,\n    [0xCB] = unpack_double,\n    [0xCC] = unpack_uint8,\n    [0xCD] = unpack_uint16,\n    [0xCE] = unpack_uint32,\n    [0xCF] = unpack_uint64,\n    [0xD0] = unpack_int8,\n    [0xD1] = unpack_int16,\n    [0xD2] = unpack_int32,\n    [0xD3] = unpack_int64,\n    [0xD4] = function (c) return unpack_ext(c, 1, unpack_int8(c)) end,\n    [0xD5] = function (c) return unpack_ext(c, 2, unpack_int8(c)) end,\n    [0xD6] = function (c) return unpack_ext(c, 4, unpack_int8(c)) end,\n    [0xD7] = function (c) return unpack_ext(c, 8, unpack_int8(c)) end,\n    [0xD8] = function (c) return unpack_ext(c, 16, unpack_int8(c)) end,\n    [0xD9] = function (c) return unpack_str(c, unpack_uint8(c)) end,\n    [0xDA] = function (c) return unpack_str(c, unpack_uint16(c)) end,\n    [0xDB] = function (c) return unpack_str(c, unpack_uint32(c)) end,\n    [0xDC] = function (c) return unpack_array(c, unpack_uint16(c)) end,\n    [0xDD] = function (c) return unpack_array(c, unpack_uint32(c)) end,\n    [0xDE] = function (c) return unpack_map(c, unpack_uint16(c)) end,\n    [0xDF] = function (c) return unpack_map(c, unpack_uint32(c)) end,\n}, {\n    __index = function (t, k)\n        if k < 0xC0 then\n            if k < 0x80 then\n                return function (c, val) return val end\n            elseif k < 0x90 then\n                return function (c, val) return unpack_map(c, val & 0xF) end\n            elseif k < 0xA0 then\n                return function (c, val) return unpack_array(c, val & 0xF) end\n            else\n                return function (c, val) return unpack_str(c, val & 0x1F) end\n            end\n        elseif k > 0xDF then\n            return function (c, val) return val - 0x100 end\n        else\n            return function () error(\"unpack \'\" .. format(\'%#x\', k) .. \"\' is unimplemented\") end\n        end\n    end\n})\n\nlocal function cursor_string (str)\n    return {\n        s = str,\n        i = 1,\n        j = #str,\n        underflow = function ()\n                        error \"missing bytes\"\n                    end,\n    }\nend\n\nlocal function cursor_loader (ld)\n    return {\n        s = \'\',\n        i = 1,\n        j = 0,\n        underflow = function (self, e)\n                        self.s = self.s:sub(self.i)\n                        e = e - self.i + 1\n                        self.i = 1\n                        self.j = 0\n                        while e > self.j do\n                            local chunk = ld()\n                            if not chunk then\n                                error \"missing bytes\"\n                            end\n                            self.s = self.s .. chunk\n                            self.j = #self.s\n                        end\n                    end,\n    }\nend\n\nfunction m.unpack (s)\n    checktype(\'unpack\', 1, s, \'string\')\n    local cursor = cursor_string(s)\n    local data = unpack_cursor(cursor)\n    if cursor.i <= cursor.j then\n        error \"extra bytes\"\n    end\n    return data\nend\n\nfunction m.unpacker (src)\n    if type(src) == \'string\' then\n        local cursor = cursor_string(src)\n        return function ()\n            if cursor.i <= cursor.j then\n                return cursor.i, unpack_cursor(cursor)\n            end\n        end\n    elseif type(src) == \'function\' then\n        local cursor = cursor_loader(src)\n        return function ()\n            if cursor.i > cursor.j then\n                pcall(cursor.underflow, cursor, cursor.i)\n            end\n            if cursor.i <= cursor.j then\n                return true, unpack_cursor(cursor)\n            end\n        end\n    else\n        argerror(\'unpacker\', 1, \"string or function expected, got \" .. type(src))\n    end\nend\n\nset_string\'string_compat\'\nset_integer\'unsigned\'\nif #pack(\'n\', 0.0) == 4 then\n    m.small_lua = true\n    unpackers[0xCB] = nil       -- double\n    unpackers[0xCF] = nil       -- uint64\n    unpackers[0xD3] = nil       -- int64\n    set_number\'float\'\nelse\n    m.full64bits = true\n    set_number\'double\'\n    if #pack(\'n\', 0.0) > 8 then\n        m.long_double = true\n    end\nend\nset_array\'without_hole\'\n\nm._VERSION = \'0.5.2\'\nm._DESCRIPTION = \"lua-MessagePack : a pure Lua 5.3 implementation\"\nm._COPYRIGHT = \"Copyright (c) 2012-2019 Francois Perrad\"\n-- luaFormatter on\n\n----------------------------------------------------------------------------\n-- Core Extensions for lua-MessagePack\n-- Copyright (c) 2021 Andrew Zhilin (https://github.com/zoon)\n----------------------------------------------------------------------------\ndo\n    -- NOTE: this is \"measure\" lite - fast but still allocates. For hardcore\n    -- version put `local char, pack = buffer.char, buffer.pack` in the first\n    -- line of every `packers[xxx]` function. Pass `char` `select(\"#, ...)`\n    -- instead of `char` and packsize instead of `pack` Memory allocation will\n    -- be near-zero, but encoding will be 10-20% slower.\n    local measure_buffer do\n        local measure_buffer_mt = {}\n        measure_buffer_mt.__index = measure_buffer_mt\n\n        function measure_buffer_mt:__newindex(_, v)\n            self.length = self.length + #v\n        end\n\n        function measure_buffer_mt:__call()\n            local length = self.length\n            self.length = 0\n            return length\n        end\n        -- assign forward declaration\n        measure_buffer = setmetatable({length = 0}, measure_buffer_mt)\n    end\n\n    -- An alias for MP.pack with *measure* option\n    -- @ encode :: data[, measure] -> str\n    -- returns MessagePack encoded string, or\n    -- with truthy `measure` option returns length of serialized string instead.\n    m.encode = function(data, measure)\n        if not measure then\n            return m.pack(data)\n        end\n        packers[type(data)](measure_buffer, data)\n        return measure_buffer()\n    end\n\n    -- @ decode :: s:str[, from=1][, to=#s] -> object | error\n    -- s: MessagePack encoded string\n    -- Returns desirialized lua data or throw an error.\n    m.decode = function(s, from, to)\n        local c = cursor_string(s)\n        c.i = from or 1\n        c.j = to or #s\n        return m.unpack_cursor(c)\n    end\n\n    -- `CoreObjectReference` has no constructor and we have to use\n    -- proxy type copying its interface\n    local CoreObjectReferenceProxy = {type = \"CoreObjectReference\"}\n    CoreObjectReferenceProxy.__index = CoreObjectReferenceProxy\n    function CoreObjectReferenceProxy.New(muid)\n        local self = {}\n        self.isAssigned = muid ~= nil\n        self.id = muid or \"0000000000000000\"\n        return setmetatable(self, CoreObjectReferenceProxy)\n    end\n\n    function CoreObjectReferenceProxy:__tostring() return format(\"%s: %s\", self.type, self.id) end\n\n    function CoreObjectReferenceProxy:IsA(typeName) return typeName == self.type end\n\n    -- NOTE: `__eq` metamethod will be called only if both operands have the\n    -- same type, i.e. `userdata` and `table` will not work. Since Lua 5.3, we\n    -- can create `userdata` exclusively through the C API. In other words,\n    -- this `==` operator rather useless and intended only for ease of writing\n    -- tests.\n    function CoreObjectReferenceProxy:__eq(other)\n        if CoreObjectReferenceProxy.type == other.type then\n            return self.id == other.id\n        end\n        return false\n    end\n\n    function CoreObjectReferenceProxy:GetObject()\n        if self.isAssigned then\n            return World.FindObjectById(self.id)\n        end\n    end\n\n    function CoreObjectReferenceProxy:WaitForObject(wait)\n        wait = wait or BIG_TIMEOUT\n        assert(type(wait) == \"number\")\n        if not self.isAssigned then\n            return nil\n        end\n        -- happy path:\n        local result = self:GetObject()\n        if result then\n            return result\n        end\n        -- unhappy path:\n        local begin = time()\n        while true do\n            Task.Wait(0.1)\n            if time() - begin >= wait then\n                return false, \"no object\"\n            end\n            result = self:GetObject()\n            if result then\n                return result\n            end\n        end\n    end\n\n    -----------------------------------\n    -- Extensions\n    -----------------------------------\n    -- Reference: https://github.com/msgpack/msgpack/blob/master/spec.md#extension-types\n\n    -- User specific type-tags [41, 127]\n    local EXT_USER_BitArray = 41\n    EXT_USER_ENCODERS[\"BitArray\"] = function(buffer, bit_array)\n        local size = bit_array.size()\n        local ntail = size%8\n        m.packers.ext(buffer, EXT_USER_BitArray, char(ntail, tunpack(bit_array)))\n    end\n    local EXT_USER_Enum = 42\n    EXT_USER_ENCODERS[\"Enum\"] = function(buffer, enum)\n        -- HACK: expose internals\n        local keys, vals = enum._keys, enum._vals\n        m.packers.ext(buffer, EXT_USER_Enum, m.pack({keys, vals}))\n    end\n\n    -- Core specific type-tags [0, 40]\n    local EXT_CORE_VECTOR3 = 0\n    local EXT_CORE_ROTATION = 1\n    local EXT_CORE_COLOR = 2\n    local EXT_CORE_VECTOR2 = 3\n    local EXT_CORE_VECTOR4 = 4\n    local EXT_CORE_PLAYER_ID_128 = 5\n    local EXT_CORE_PLAYER_ID_STR = 6\n    local EXT_CORE_OBJECT_REFERENCE_ID_64 = 7\n    local EXT_CORE_OBJECT_REFERENCE_ID_STR = 8\n\n    -- All Core constants will have tag=40 and data:DATA_CORE_CONST_XXX\n    local EXT_CORE_CONST = 40\n\n    -- Core constants will have Tag = EXT_CORE_CONST (40) and data:DATA_CORE_CONST_XXX\n    -- CoreObjectReference\n    local DATA_CORE_CONST_REFERENCE_NOT_ASSIGNED = char(0)\n    -- 1..9 reserved\n\n    -- Color\n    local DATA_CORE_CONST_COLOR_WHITE = char(10)\n    local DATA_CORE_CONST_COLOR_GRAY = char(11)\n    local DATA_CORE_CONST_COLOR_BLACK = char(12)\n    local DATA_CORE_CONST_COLOR_TRANSPARENT = char(13)\n    local DATA_CORE_CONST_COLOR_RED = char(14)\n    local DATA_CORE_CONST_COLOR_GREEN = char(15)\n    local DATA_CORE_CONST_COLOR_BLUE = char(16)\n    local DATA_CORE_CONST_COLOR_CYAN = char(17)\n    local DATA_CORE_CONST_COLOR_MAGENTA = char(18)\n    local DATA_CORE_CONST_COLOR_YELLOW = char(19)\n    local DATA_CORE_CONST_COLOR_ORANGE = char(20)\n    local DATA_CORE_CONST_COLOR_PURPLE = char(21)\n    local DATA_CORE_CONST_COLOR_BROWN = char(22)\n    local DATA_CORE_CONST_COLOR_PINK = char(23)\n    local DATA_CORE_CONST_COLOR_TAN = char(24)\n    local DATA_CORE_CONST_COLOR_RUBY = char(25)\n    local DATA_CORE_CONST_COLOR_EMERALD = char(26)\n    local DATA_CORE_CONST_COLOR_SAPPHIRE = char(27)\n    local DATA_CORE_CONST_COLOR_SILVER = char(28)\n    local DATA_CORE_CONST_COLOR_SMOKE = char(29)\n    -- 30 .. 39 reserved\n\n    -- Vector2\n    local DATA_CORE_CONST_VECTOR2_ONE = char(40)\n    local DATA_CORE_CONST_VECTOR2_ZERO = char(41)\n    -- 42 .. 49 reserved\n\n    -- Vector3\n    local DATA_CORE_CONST_VECTOR3_ONE = char(51)\n    local DATA_CORE_CONST_VECTOR3_ZERO = char(52)\n    local DATA_CORE_CONST_VECTOR3_FORWARD = char(53)\n    local DATA_CORE_CONST_VECTOR3_UP = char(54)\n    local DATA_CORE_CONST_VECTOR3_RIGHT = char(55)\n    -- 56 .. 59 reserved\n\n    -- Vector4\n    local DATA_CORE_CONST_VECTOR4_ONE = char(60)\n    local DATA_CORE_CONST_VECTOR4_ZERO = char(61)\n    -- 62 .. 69 reserved\n\n    -- Rotation\n    local DATA_CORE_CONST_ROTATION_ZERO = char(70)\n    -- 71 .. 79 reserved\n    -- 80 .. 255 free\n\n    -- Core constants lookup table {data -> Core Constant}\n    local CORE_CONST_DECODE = not CORE_ENV and {} or {\n        [DATA_CORE_CONST_REFERENCE_NOT_ASSIGNED] = CoreObjectReferenceProxy.New(nil),\n\n        [DATA_CORE_CONST_COLOR_WHITE] = Color.WHITE,\n        [DATA_CORE_CONST_COLOR_GRAY] = Color.GRAY,\n        [DATA_CORE_CONST_COLOR_BLACK] = Color.BLACK,\n        [DATA_CORE_CONST_COLOR_TRANSPARENT] = Color.TRANSPARENT,\n        [DATA_CORE_CONST_COLOR_RED] = Color.RED,\n        [DATA_CORE_CONST_COLOR_GREEN] = Color.GREEN,\n        [DATA_CORE_CONST_COLOR_BLUE] = Color.BLUE,\n        [DATA_CORE_CONST_COLOR_CYAN] = Color.CYAN,\n        [DATA_CORE_CONST_COLOR_MAGENTA] = Color.MAGENTA,\n        [DATA_CORE_CONST_COLOR_YELLOW] = Color.YELLOW,\n        [DATA_CORE_CONST_COLOR_ORANGE] = Color.ORANGE,\n        [DATA_CORE_CONST_COLOR_PURPLE] = Color.PURPLE,\n        [DATA_CORE_CONST_COLOR_BROWN] = Color.BROWN,\n        [DATA_CORE_CONST_COLOR_PINK] = Color.PINK,\n        [DATA_CORE_CONST_COLOR_TAN] = Color.TAH,\n        [DATA_CORE_CONST_COLOR_RUBY] = Color.RUBY,\n        [DATA_CORE_CONST_COLOR_EMERALD] = Color.EMERALD,\n        [DATA_CORE_CONST_COLOR_SAPPHIRE] = Color.SAPPHIRE,\n        [DATA_CORE_CONST_COLOR_SILVER] = Color.SILVER,\n        [DATA_CORE_CONST_COLOR_SMOKE] = Color.SMOKE,\n\n        [DATA_CORE_CONST_VECTOR2_ONE] = Vector2.ONE,\n        [DATA_CORE_CONST_VECTOR2_ZERO] = Vector2.ZERO,\n\n        [DATA_CORE_CONST_VECTOR3_ONE] = Vector3.ONE,\n        [DATA_CORE_CONST_VECTOR3_ZERO] = Vector3.ZERO,\n        [DATA_CORE_CONST_VECTOR3_FORWARD] = Vector3.FORWARD,\n        [DATA_CORE_CONST_VECTOR3_UP] = Vector3.UP,\n        [DATA_CORE_CONST_VECTOR3_RIGHT] = Vector3.RIGHT,\n\n        [DATA_CORE_CONST_VECTOR4_ONE] = Vector4.ONE,\n        [DATA_CORE_CONST_VECTOR4_ZERO] = Vector4.ZERO,\n        [DATA_CORE_CONST_ROTATION_ZERO] = Rotation.ZERO\n    }\n\n    -- Core constant colors lookup table (Color -> EXT_CORE_COLOR_XXX)\n    local CORE_CONST_COLOR_ENCODE = {}\n    for data, value in pairs(CORE_CONST_DECODE) do\n        if value.type == \"Color\" then\n            CORE_CONST_COLOR_ENCODE[value] = data\n        end\n    end\n\n    -----------------------------------\n    -- Core serialization\n    -----------------------------------\n    local EXT_CORE_ENCODERS = {\n        CoreObjectReference = function(buffer, udata)\n            if not udata.isAssigned then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_REFERENCE_NOT_ASSIGNED)\n            else\n                local id = CoreString.Split(udata.id, \":\")\n                local uid64 = tonumber(id, 16)\n                -- NOTE: be conservative: there is no guarantee that `id` retuns 64-bit hex-encoded number\n                if uid64 then\n                    m.packers.fixext8(buffer, EXT_CORE_OBJECT_REFERENCE_ID_64, pack(\"I8\", uid64))\n                else -- failsafe scenario: use id string as-is\n                    assert(udata.id and type(udata.id) == \"string\", \"CoreObjectReference has no id\")\n                    print(\"INFO: object\'s MUID is not a 64-bit number:\", udata.id)\n                    m.packers.ext(buffer, EXT_CORE_OBJECT_REFERENCE_ID_STR, udata.id)\n                end\n            end\n        end,\n        Color = function(buffer, udata)\n            local data = CORE_CONST_COLOR_ENCODE[udata]\n            if data then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, data)\n            else\n                m.packers.fixext4(buffer, EXT_CORE_COLOR, pack(\"BBBB\", udata.r, udata.g, udata.b, udata.a))\n            end\n        end,\n        Player = function(buffer, udata)\n            assert(udata.id and type(udata.id) == \"string\")\n            local str128 = nil\n            -- if id is UUID, try to serialize it as a pair of uint64\n            if #udata.id == 32 then\n                local first64, second64 = tonumber(udata.id:sub(1, 16), 16), tonumber(udata.id:sub(17, 32), 16)\n                if first64 and second64 then\n                    str128 = pack(\"I8I8\", first64, second64)\n                end\n            end\n            -- be conservative, do roundtrip check\n            if str128 and format(\"%x%x\", unpack(\"I8I8\", str128)) == udata.id then -- we good\n                m.packers.fixext16(buffer, EXT_CORE_PLAYER_ID_128, str128)\n            else -- save verbatim id as a string\n                m.packers.ext(buffer, EXT_CORE_PLAYER_ID_STR, udata.id)\n            end\n        end,\n        Rotation = function(buffer, udata)\n            if udata == Rotation.ZERO then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_ROTATION_ZERO)\n            else\n                m.packers.ext(buffer, EXT_CORE_ROTATION, pack(\"fff\", udata.x, udata.y, udata.z))\n            end\n        end,\n        Vector2 = function(buffer, udata)\n            if udata == Vector2.ONE then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR2_ONE)\n            elseif udata == Vector2.ZERO then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR2_ZERO)\n            else\n                m.packers.fixext8(buffer, EXT_CORE_VECTOR2, pack(\"ff\", udata.x, udata.y))\n            end\n        end,\n        Vector3 = function(buffer, udata)\n            if udata == Vector3.ONE then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR3_ONE)\n            elseif udata == Vector3.ZERO then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR3_ZERO)\n            elseif udata == Vector3.FORWARD then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR3_FORWARD)\n            elseif udata == Vector3.UP then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR3_UP)\n            elseif udata == Vector3.RIGHT then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR3_RIGHT)\n            else\n                m.packers.ext(buffer, EXT_CORE_VECTOR3, pack(\"fff\", udata.x, udata.y, udata.z))\n            end\n        end,\n        Vector4 = function(buffer, udata)\n            if udata == Vector4.ONE then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR4_ONE)\n            elseif udata == Vector4.ZERO then\n                m.packers.fixext1(buffer, EXT_CORE_CONST, DATA_CORE_CONST_VECTOR4_ZERO)\n            else\n                m.packers.fixext16(buffer, EXT_CORE_VECTOR4, pack(\"ffff\", udata.x, udata.y, udata.z, udata.w))\n            end\n        end,\n    }\n\n    -- NB. we need this for symmetry\n    EXT_USER_ENCODERS[CoreObjectReferenceProxy.type] = EXT_CORE_ENCODERS.CoreObjectReference\n\n    -- TODO: lookup table for top level\n    m.packers[\"userdata\"] = function(buffer, udata)\n        local encoder = EXT_CORE_ENCODERS[udata.type]\n        if encoder then\n            encoder(buffer, udata)\n        else\n            error(\"unsuported userdata: \" .. tostring(udata))\n        end\n    end\n\n    -----------------------------------\n    -- Core deserialization\n    -----------------------------------\n    -- TODO: lookup table\n    local EXT_DECODERS = {\n        -- Core -------------\n        [EXT_CORE_VECTOR3] = function(data)\n            local x, y, z = unpack(\"fff\", data)\n            return Vector3.New(x, y, z)\n        end,\n        [EXT_CORE_ROTATION] = function(data)\n            local x, y, z = unpack(\"fff\", data)\n            return Rotation.New(x, y, z)\n        end,\n        [EXT_CORE_COLOR] = function(data)\n            local r, g, b, a = unpack(\"BBBB\", data)\n            return Color.New(r, g, b, a)\n        end,\n        [EXT_CORE_VECTOR2] = function(data)\n            local x, y = unpack(\"ff\", data)\n            return Vector2.New(x, y)\n        end,\n        [EXT_CORE_VECTOR4] = function(data)\n            local x, y, z, w = unpack(\"ffff\", data)\n            return Vector4.New(x, y, z, w)\n        end,\n        [EXT_CORE_PLAYER_ID_128] = function(data)\n            local first, second = unpack(\"I8I8\", data)\n            local id = format(\"%x%x\", first, second)\n            return Game.FindPlayer(id)\n        end,\n        [EXT_CORE_PLAYER_ID_STR] = function(data)\n            return Game.FindPlayer(data)\n        end,\n        [EXT_CORE_OBJECT_REFERENCE_ID_64] = function(data)\n            local uid64 = unpack(\"I8\", data)\n            local muid = format(\"%X\", uid64)\n            return CoreObjectReferenceProxy.New(muid)\n        end,\n        [EXT_CORE_OBJECT_REFERENCE_ID_STR] = function(data)\n            return CoreObjectReferenceProxy.New(data)\n        end,\n        -- User -------------\n        [EXT_USER_BitArray] = function(data)\n            local ntail = byte(data, 1)\n            local size = 8 * (#data - 1)\n            size = ntail == 0 and size or (size - 8 + ntail)\n            local ba = {byte(data, 2, #data)}\n            ba.size = function() return size end\n            -- HACK: workaround for initialization order of user type\n            local BitArray = require(\"BitArray\")\n            return setmetatable(ba, BitArray)\n        end,\n        [EXT_USER_Enum] = function(data)\n            local Enum = require(\"Enum\")\n            return Enum.from_kv(data[1], data[2])\n        end\n    }\n    -------------------------\n    -- build_ext\n    -------------------------\n    m.build_ext = function(tag, data)\n        if tag == EXT_CORE_CONST then\n            return CORE_CONST_DECODE[data] or error(format(\"unknown DATA_CORE_CONST: %s\", data))\n        else\n            local decoder = EXT_DECODERS[tag]\n            return decoder and decoder(data) or error(format(\"unknown extension tag: %d\", tag))\n        end\n    end\n\n    -----------------------------------\n    -- Test\n    -----------------------------------\n    local function test_measure()\n\n        assert(type(m.encode(\"hello\", \"measure\")) == \"number\")\n\n        local data = {\n            0xf,\n            123,\n            1234,\n            1234567890,\n            \"hello\",\n            {1, \"hello\"},\n            {1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, {1, 2, 3}},\n            3.14159265359,\n            {3.14159265359},\n            {{{{{{0}}}}}}\n        }\n        for i, v in pairs(data) do\n            assert(#m.encode(v) == m.encode(v, \"measure\"), \"#\"..i)\n        end\n        assert(#m.encode(data) == m.encode(data, \"measure\"))\n        print(\"  test_measure -- ok\")\n    end\n\n    local function core_types_test()\n        if not CORE_ENV then\n            print(\"  core_types_test -- skipped\")\n            return\n        end\n        local core_data = {\n            Vector2.New(1.1, 2.2),\n            Vector3.New(1.1, 2.2, 3.3),\n            Vector4.New(1.1, 2.2, 3.3, 4.4),\n            Rotation.New(1.1, 2.2, 3.3),\n            Color.New(0, 127, 255, 100),\n        }\n        for _, val in ipairs(core_data) do\n            local p = m.encode(val)\n            local v = m.decode(p)\n            assert(v == val, tostring(val))\n        end\n\n        for _, val in pairs(CORE_CONST_DECODE) do\n            local p = m.encode(val)\n            local v = m.decode(p)\n            assert(v == val, tostring(val))\n        end\n\n        print(\"  core_types_test -- ok\")\n    end\n\n    local function test_user_types()\n        -- HACK: workaround for initialization order of user type\n        local BitArray = require(\"BitArray\")\n        local b = BitArray.new(577)\n        b:set(12, true)\n        b:set(17, true)\n        b:set(300, true)\n        local bmp = m.encode(b)\n        local bmpe = m.decode(bmp)\n        assert(b == bmpe)\n        print(\"  test_user_types -- ok\")\n    end\n\n    local function self_test()\n        print(\"[lua-MessagePack]\")\n        core_types_test()\n        test_measure()\n        -- HACK: workaround for initialization order of user type\n        if not CORE_ENV then\n            test_user_types()\n        end\n    end\n\n    -- run test\n    self_test()\n\n    ---------------------------------------------\n    -- Default serialization settings for Core\n    ---------------------------------------------\n    set_array(\"without_hole\")\n    set_string(\"string\")\n    set_number(\"double\")\n\nend -- end of extensions\n\nreturn m\n--\n-- This library is licensed under the terms of the MIT/X11 license,\n-- like Lua itself.\n--\n"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 10876574309383257670
      Name: "Enum"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- The MIT Licence (MIT)\r\n-- Copyright (c) 2021 Andrew Zhilin (https://github.com/zoon)\r\n--[[\r\n    Enum: readonly ordered (by value) hash table with integer values.\r\n    Index returns value by key and key by value.\r\n    Main purpose - keys for networking events (hence the optimization for message pack).\r\n\r\n    Interface:\r\n     - Enum.New(key1, key2)   -> Enum { key1 = 1,  key2 = 2}\r\n     - Enum{key1=11, key2=22} -> Enum { key1 = 11, key2 = 22}\r\n\r\n     local e = Enum{a=11}\r\n     e[11]    -> \"a\"\r\n     e.a      -> 11\r\n     e[\"a\"]   -> 11\r\n     e.a = 12 -> error\r\n\r\n     for k, v in pairs(e) do print(k, v) end -> a 11\r\n     print(e) -> Enum {a = 11}\r\n\r\n     (!) MP serialization:\r\n        local enc = MessagePack.encode(enum)\r\n        local enum1 = Enum(MessagePack.decode(enc))\r\n]]\r\n\r\nlocal type, mtype = type, math.type\r\nlocal select = select\r\nlocal setmetatable = setmetatable\r\nlocal tonumber = tonumber\r\nlocal error = error\r\nlocal assert = assert\r\nlocal pcall = pcall\r\nlocal print = print\r\nlocal concat = table.concat\r\nlocal pairs = pairs\r\nlocal format = string.format\r\nlocal CORE_ENV = CoreDebug and true\r\nlocal get_trace = CORE_ENV and CoreDebug.GetStackTrace or function() return \"\" end\r\nlocal MIN_INT = math.mininteger\r\nlocal MAX_INT = math.maxinteger\r\n\r\n\r\n-- Message Pack 1 byte should be in [-32, 127]\r\nlocal MIN_MP_OPT = -32\r\nlocal MAX_MP_OPT = 127\r\n\r\n_ENV = nil\r\n\r\n-- insertion sort\r\nlocal function isort(keys, vals)\r\n    local n = #vals\r\n    for i = 2, n do\r\n        local val = vals[i]\r\n        local key = keys[i]\r\n        local j = i - 1\r\n        while j > 0 and val < vals[j] do\r\n            vals[j + 1] = vals[j]\r\n            keys[j + 1] = keys[j]\r\n            j = j - 1\r\n        end\r\n        vals[j + 1] = val\r\n        keys[j + 1] = key\r\n    end\r\n    return keys, vals\r\nend\r\n\r\nlocal function isort_gt(keys, vals)\r\n    local n = #vals\r\n    for i = 2, n do\r\n        local val = vals[i]\r\n        local key = keys[i]\r\n        local j = i - 1\r\n        while j > 0 and vals[j] < val do\r\n            vals[j + 1] = vals[j]\r\n            keys[j + 1] = keys[j]\r\n            j = j - 1\r\n        end\r\n        vals[j + 1] = val\r\n        keys[j + 1] = key\r\n    end\r\n    return keys, vals\r\nend\r\n\r\nlocal Enum_mt = {}\r\nEnum_mt.__index = Enum_mt\r\n\r\n---@class Enum\r\nlocal Enum = setmetatable({type = \"Enum\"}, Enum_mt)\r\nEnum.__index = Enum\r\n\r\n---@return Enum\r\nfunction Enum_mt:__call(...)\r\n    return Enum.from_table(...)\r\nend\r\n\r\nfunction Enum.is(any)\r\n    return type(any) == \"table\" and any.type == Enum.type\r\nend\r\n\r\n-- [from, max]\r\n-- NB. works only for *less* enums\r\nfunction Enum.is_in(any, min_value, max_value)\r\n    if type(any) ~= \"table\" or any.type ~= Enum.type then return false end\r\n    if not max_value then return any._vals[1] == min_value end\r\n    local vals = any._vals\r\n    return vals[1] == min_value and vals[#vals] <= max_value\r\nend\r\n\r\nlocal function from_kv(keys, vals, min_value, max_value)\r\n    min_value = min_value or MIN_INT\r\n    max_value = max_value or MAX_INT\r\n    local reverse = {}\r\n    local n = #keys\r\n    if n == 0 then\r\n        error(\"Enum is empty\", 2)\r\n    end\r\n    for i=1, #keys do\r\n        local k, v = keys[i], vals[i]\r\n        if type(k) ~= \"string\" or tonumber(k) then error((\"Enum: key \'[%s] = %s\' must be a string id\"):format(k, v), 3) end\r\n        if mtype(v) ~= \"integer\" or v > max_value or v < min_value then\r\n            error(format(\"Enum: \'%s = %s\': value must be an integer in [%d, %d]\", k, v, min_value, max_value), 3)\r\n        end\r\n        if reverse[v] then\r\n            local dup = keys[reverse[v]]\r\n            error(format(\"Enum: duplicated value: \'%s\' for keys: \'%s\', \'%s\'\", v, k, dup), 3)\r\n        end\r\n        reverse[k] = i\r\n        reverse[v] = i\r\n    end\r\n    return setmetatable({_keys = keys, _vals = vals, _reverse=reverse}, Enum)\r\nend\r\n\r\n-- export it for serialization purposes\r\nEnum.from_kv = from_kv\r\n\r\n-- New :: keys ... -> Enum\r\n---@return Enum\r\nfunction Enum.New(...)\r\n    local keys = {}\r\n    local vals = {}\r\n    for i = 1, select(\"#\", ...) do\r\n        keys[i] = select(i, ...)\r\n        vals[i] = i\r\n    end\r\n    return from_kv(keys, vals)\r\nend\r\n\r\n---@return Enum\r\nfunction Enum.from_table(t, min, max)\r\n    local keys = {}\r\n    local vals = {}\r\n    for k, v in pairs(t) do\r\n        local i = #keys + 1\r\n        keys[i] = k\r\n        vals[i] = v\r\n    end\r\n    keys, vals = isort(keys, vals)\r\n    return from_kv(keys, vals, min, max)\r\nend\r\n\r\n-- Message Pack optimized: values in [-32, 127]\r\n---@return Enum\r\nfunction Enum.mp(t)\r\n    local keys = {}\r\n    local vals = {}\r\n    for k, v in pairs(t) do\r\n        local i = #keys + 1\r\n        keys[i] = k\r\n        vals[i] = v\r\n    end\r\n    keys, vals = isort(keys, vals)\r\n    return from_kv(keys, vals, MIN_MP_OPT, MAX_MP_OPT)\r\nend\r\n\r\n-- max-first ordered enum\r\n---@return Enum\r\nfunction Enum.gt(t)\r\n    local keys = {}\r\n    local vals = {}\r\n    for k, v in pairs(t) do\r\n        local i = #keys + 1\r\n        keys[i] = k\r\n        vals[i] = v\r\n    end\r\n    keys, vals = isort_gt(keys, vals)\r\n    return from_kv(keys, vals)\r\nend\r\n\r\n---@return Enum\r\nfunction Enum.uint8(t)\r\n    local keys = {}\r\n    local vals = {}\r\n    for k, v in pairs(t) do\r\n        local i = #keys + 1\r\n        keys[i] = k\r\n        vals[i] = v\r\n    end\r\n    keys, vals = isort(keys, vals)\r\n    return from_kv(keys, vals, 0, 255)\r\nend\r\n\r\nfunction Enum:__tostring()\r\n    local out = {\"Enum {\"}\r\n    for k, v in pairs(self) do\r\n        out[#out + 1] = format(\"  %s = %d,\", k, v)\r\n    end\r\n    out[#out + 1] = \"}\"\r\n    return concat(out, \"\\n\")\r\nend\r\n\r\nfunction Enum:__index(k)\r\n    if k == \"type\" then return Enum.type end\r\n    local i = self._reverse[k]\r\n    if mtype(k) == \"integer\" then\r\n        return self._keys[i] or error(format(\"Enum has no value: \'%s\'\\n%s\\n%s\", k, self, get_trace()), 2)\r\n    end\r\n    return self._vals[i] or error(format(\"Enum has no key: \'%s\'\", k), 2)\r\nend\r\n\r\nfunction Enum:__newindex(_)\r\n    error(\"Enum is read-only\", 2)\r\nend\r\n\r\nfunction Enum:__len() return #self._keys end\r\n\r\nlocal function enum_next(t, k)\r\n    local i = k and t._reverse[k] or 0\r\n    return t._keys[i + 1], t._vals[i + 1]\r\nend\r\n\r\nfunction Enum:__pairs()\r\n    return enum_next, self, nil\r\nend\r\n\r\nfunction Enum.get_kv(self)\r\n    return self._keys, self._vals\r\nend\r\n\r\n--[[ NOTE: there is no __ipairs metamethod in vanilla Lua 5.3\r\nlocal function _inext(t, v)\r\n    local i = v and t._reverse[v] or 0\r\n    return t._vals[i + 1], t._keys[i + 1]\r\nend\r\n\r\nfunction Enum:__ipairs()\r\n    return _inext, self, nil\r\nend\r\n--]]\r\n\r\n-----------------------------\r\n-- Test\r\n-----------------------------\r\nlocal function self_test()\r\n    assert(not pcall(Enum, {uno=1, one=1}))\r\n    assert(not pcall(Enum, {[\"1\"]=1}))\r\n    assert(not pcall(Enum, {pi=3.14}))\r\n    assert(not pcall(Enum, {[{}]=3}))\r\n    local e = Enum {a=1}\r\n    assert(Enum.is(e))\r\n    assert(not Enum.is({}))\r\n    assert(not Enum.is(0))\r\n    assert(Enum.is_in(e, 1))\r\n    assert(Enum.is_in(e, 1, 32))\r\n    assert(not pcall(function() return e[3] end))\r\n    assert(not pcall(function() return e.WRONG end))\r\n    assert(not pcall(function () return Enum{} end))\r\n    e = Enum.New(\"One\", \"Two\", \"Three\")\r\n    assert(e.One == 1)\r\n    assert(e[3] == \"Three\")\r\n    e = Enum{A = -3, B = -1, C = 0, D = 11, E=14}\r\n    assert(Enum.is_in(e, -3, 999))\r\n    for k, v in pairs(e) do\r\n        assert(e[k] == v and e[v] == k)\r\n    end\r\n\r\n    local _roman = Enum.gt {\r\n        I = 1,\r\n        V = 5,\r\n        X = 10,\r\n        L = 50,\r\n        C = 100,\r\n        D = 500,\r\n        M = 1000\r\n    }\r\n    for k, v in pairs(_roman) do\r\n        assert(v == 1000)\r\n        break\r\n    end\r\n\r\n    -- roundtrip or roman\r\n    local keys, vals = {}, {}\r\n    for k, v in pairs(_roman) do\r\n        keys[#keys+1] = k\r\n        vals[#vals+1] = v\r\n    end\r\n    local ert =  from_kv(keys, vals)\r\n    assert(#ert == #_roman)\r\n    for k, v in pairs(_roman) do\r\n        assert(_roman[k] == ert[k])\r\n        assert(_roman[v] == ert[v])\r\n    end\r\n\r\n    -- print(Enum.New(\"key1\", \"key2\"))\r\n    print(\"enum -- ok\")\r\nend\r\nself_test()\r\n\r\nreturn Enum\r\n"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 16087391583451673026
      Name: "BitArray"
      PlatformAssetType: 3
      TextAsset {
        Text: "-- fixed size compact, serializable bitarray\r\n-- NB. as 11.10.2021 - breaking change: 0-based indices\r\nlocal BitArray = {type = \"BitArray\"}\r\nBitArray.__index = BitArray\r\n\r\nlocal function nbytes(size)\r\n    local r, n = size % 8, size // 8\r\n    return r == 0 and n or n + 1, r\r\nend\r\n\r\nfunction BitArray.new(size, default)\r\n    size = size or 32\r\n    local n, used = nbytes(size)\r\n    local _size = size\r\n    -- hide _size in closure\r\n    local self = {size = function() return _size end}\r\n\r\n    local fill = default and 0xFF or 0x00\r\n    for i = 1, n do\r\n        self[i] = fill\r\n    end\r\n    -- set unused bits to zero for correct equality compare\r\n    self[#self] = self[#self] & ~(-1 << used)\r\n    return setmetatable(self, BitArray)\r\nend\r\nBitArray.New = BitArray.new\r\n\r\n-- bitarray.eq :: self, other -> bool\r\nlocal rawequal = rawequal\r\nfunction BitArray:eq(other)\r\n    if rawequal(self, other) then\r\n        return true\r\n    end\r\n    if other.type ~= BitArray.type then\r\n        return false\r\n    end\r\n    local size = self.size()\r\n    if size ~= other.size() then\r\n        return false\r\n    end\r\n    local n, _ = nbytes(size)\r\n    for i = 1, n - 1 do\r\n        if self[i] ~= other[i] then\r\n            return false\r\n        end\r\n    end\r\n    return self[n] == other[n]\r\nend\r\n\r\n-- `==` overload\r\nBitArray.__eq = BitArray.eq\r\n\r\n-- @ bitarray.set :: self, i, bool ^-> self\r\nfunction BitArray:set(i, val)\r\n    assert(i >= 0 and i < self.size())\r\n    local idx, bit = i // 8 + 1, i % 8\r\n    local byte = self[idx]\r\n    byte = val and byte | (1 << bit) or byte & ~(1 << bit)\r\n    self[idx] = byte\r\n    return self\r\nend\r\n\r\n-- @ bitarray.get :: self, i -> bool\r\nfunction BitArray:get(i)\r\n    assert(i >= 0 and i < self.size())\r\n    local idx, bit = i // 8 + 1, i % 8\r\n    return self[idx] & (1 << bit) ~= 0\r\nend\r\n\r\n-- @ bitarray.find_and_swap :: self[, bool=false] ^-> i | nil\r\n-- finds first asked boolean value, swap it and return it\'s index\r\nfunction BitArray:find_and_swap(bool)\r\n    bool = bool and true or false\r\n    for i = 0, self.size() - 1 do\r\n        if bool == self:get(i) then\r\n            self:set(i, not bool)\r\n            return i\r\n        end\r\n    end\r\nend\r\n\r\n-- NB. default always false(0)\r\nfunction BitArray:expand(new_size)\r\n    assert(new_size > self.size(), \"new size should be greater than current size\")\r\n    local out = BitArray.new(new_size)\r\n    for i=1, #self do\r\n        out[i] = self[i]\r\n    end\r\n    return out\r\nend\r\n\r\n-- @ bitarray.swap :: self, i ^-> i\r\n-- swap boolean at index i\r\nfunction BitArray:swap(i)\r\n    assert(i >= 0 and i < self.size())\r\n    local val = self:get(i)\r\n    self:set(i, not val)\r\n    return i\r\nend\r\n\r\n-- NOTE: 0-based index array\r\nlocal BIT_COUNT_BYTE = {[0]=\r\n    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\r\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\r\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\r\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\r\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\r\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\r\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\r\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\r\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\r\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\r\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\r\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\r\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\r\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\r\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\r\n    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\r\n}\r\n\r\nfunction BitArray:popcount()\r\n    local count = 0\r\n    for i = 1, #self do\r\n        count = count + BIT_COUNT_BYTE[self[i]]\r\n    end\r\n    return count\r\nend\r\n\r\n-------------------------------------------------------------------------------\r\nlocal function _bitarray_test()\r\n    local ba1 = BitArray.new(9, true)\r\n    assert(ba1.size() == 9)\r\n    assert(ba1:eq(ba1))\r\n    assert(ba1 == ba1)\r\n    ba1:set(1, nil)\r\n    assert(not ba1:get(1))\r\n    assert(ba1:get(2) and ba1:get(8))\r\n\r\n    local ba2 = BitArray.new(7)\r\n    assert(ba2.size() == 7)\r\n    assert(ba2:find_and_swap() == 0 and ba2:get(0))\r\n    ba2:swap(0)\r\n    assert(not ba2:get(0))\r\n    ba2:set(1, true):set(6, true)\r\n    for i = 0, 6 do\r\n        if i == 1 or i == 6 then\r\n            assert(ba2:get(i))\r\n        else\r\n            assert(not ba2:get(i))\r\n        end\r\n    end\r\n\r\n    -- still equal with different fills\r\n    local ba71 = BitArray.new(7, true)\r\n    local ba72 = BitArray.new(7, false)\r\n    for i = 0, ba72.size() - 1 do\r\n        ba72:set(i, true)\r\n    end\r\n    assert(ba71:eq(ba72))\r\n    ba71:set(2, nil)\r\n    ba72:set(2, nil)\r\n    assert(ba71:eq(ba72))\r\n\r\n    -- expand\r\n    local ba_9 = BitArray.new(9, true)\r\n    local ba_11 = ba_9:expand(11)\r\n    assert(ba_11:size() == 11)\r\n    assert(ba_11:popcount() == 9)\r\n    assert(ba_11:popcount() == ba_9:popcount())\r\n\r\n    for i=0, ba_9.size() - 1 do\r\n        assert(ba_9[i] == ba_11[i])\r\n    end\r\n    for i = ba_9.size() - 1, ba_11:size() - 1 do\r\n        assert(not ba_11[i])\r\n    end\r\n    --\r\n    print(\"bitarray -- ok\")\r\n\r\nend\r\n\r\n_bitarray_test()\r\n\r\nreturn BitArray\r\n"
      }
      VirtualFolderPath: "easyStorage"
    }
    Assets {
      Id: 9898829530473888574
      Name: "easyStorageAPI"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\n    API holder for easyStorage\n    TODO: Concurrent Player Data\n    Copyright (c) 2021 Andrew Zhilin (https://github.com/zoon).\n    Core user: zoonior https://www.coregames.com/user/eec0239c0d644f5bb9f59779307edb17\n\n    easyStorageAPI is a module, to import it:\n    ```\n    _ENV.require = _G.import or require\n    local easyStorageAPI = require \"easyStorageAPI\"\n    ```\n    = Server and Client API:\n\n        ---@param data any\n        ---@param toBase64 boolean -- optional (false)\n        ---@return string\n        * easyStorageAPI.CompressData(data, toBase64)\n\n        ---@param compressedData string -- output of CompressData\n        ---@param fromBase64 boolean    -- mandatory, if data was compressed with toBase64=true\n        ---@return any\n        * easyStorageAPI:DecompressData(compressedData, fromBase64)\n\n    = Server only API:\n        ---@param player Player\n        ---@return table   -- player data\n        ---@return integer -- version of data in storage\n        * easyStorageAPI.GetPlayerData(player)\n\n        ---@param player Player\n        ---@param data table\n        ---@return StorageResultCode\n        * easyStorageAPI.SetPlayerData(player, data)\n\n        ---@param player Player\n        ---@return table   -- player data\n        ---@return integer -- version of data in storage\n        * easyStorageAPI.GetSharedPlayerData(player)\n\n        ---@param player Player\n        ---@param data table\n        ---@return StorageResultCode\n        * easyStorageAPI.SetSharedPlayerData(player, data)\n]]\n_ENV.require = _G.import or require\nlocal mp = require(\"MessagePack\")\nlocal b64 = require(\"QuickBase64\")\nlocal lzw = require(\"LibLZW\")\n\nlocal format = string.format\nlocal assert, error, type = assert, error, type\n\nlocal SERVER = Environment.IsServer()\n\nlocal ROOT = World.FindObjectByName(\"@easyStorage\")\nassert(ROOT, \"error: can\'t find object by name: \'@easyStorage\'\")\n\nlocal STORAGE_VERSION = ROOT:GetCustomProperty(\"STORAGE_VERSION\")\nlocal SHARED_STORAGE_VERSION = ROOT:GetCustomProperty(\"SHARED_STORAGE_VERSION\")\nlocal SHARED_STORAGE_KEY = ROOT:GetCustomProperty(\"SHARED_STORAGE_KEY\")\nif SHARED_STORAGE_KEY then\n    assert(SHARED_STORAGE_VERSION > 0, \"SHARED_STORAGE_VERSION must be > 0\")\nend\n\n---------------------------------------\n-- easyStorage API module\n---------------------------------------\nlocal easyStorageAPI = {type=\"easyStorageAPI\"}\neasyStorageAPI.__index = easyStorageAPI\n\n------------------------------\n-- Constants\n------------------------------\n-- NB. keys should be resonably short\nlocal COMPRESSED_DATA_KEY = \"@data\"\nlocal VERSION_KEY = \"@data_ver\"\nlocal MAX_STORAGE_DATA_SIZE = 32768 -- ref: https://docs.coregames.com/api/storage/\n\n-- export\neasyStorageAPI.VERSION_KEY = VERSION_KEY\neasyStorageAPI.STORAGE_VERSION = STORAGE_VERSION\neasyStorageAPI.SHARED_STORAGE_VERSION = SHARED_STORAGE_VERSION\n\n\nlocal function compress(data)\n    local ok, compressed_data = pcall(function()\n        local bin = mp.encode(data)\n        local z = lzw.compress(bin)\n        return b64.encode(z)\n    end)\n    if not ok then\n        error(\"compression error: \" .. compressed_data, 3)\n    end\n    return compressed_data\nend\n\nlocal function decompress(compressed_data)\n    local ok, data = pcall(function()\n        local z = b64.decode(compressed_data)\n        local bin = lzw.decompress(z)\n        return mp.decode(bin)\n    end)\n    if not ok then\n        error(\"decompression error: \" .. data, 3)\n    end\n    return data\nend\n\nlocal epock\n\n---@param data any\n---@param toBase64 boolean -- optional (false)\n---@return string\nfunction easyStorageAPI.CompressData(data, toBase64)\n    local ok, compressed_data = pcall(function()\n        local bin = mp.encode(data)\n        local z = lzw.compress(bin)\n        return not toBase64 and z or b64.encode(z)\n    end)\n    if not ok then\n        error(\"compression error: \" .. compressed_data, 2)\n    end\n    return compressed_data\nend\n\n---@param compressedData string -- output of CompressData\n---@param fromBase64 boolean    -- mandatory, if data was compressed with toBase64=true\n---@return any\nfunction easyStorageAPI.DecompressData(compressedData, fromBase64)\n    assert(type(compressedData) == \"string\", type(compressedData))\n    local ok, data = pcall(function()\n        local z = not fromBase64 and compressedData or b64.decode(compressedData)\n        local bin = lzw.decompress(z)\n        return mp.decode(bin)\n    end)\n    if not ok then\n        error(\"decompression error: \" .. data, 2)\n    end\n    return data\nend\n\nif SERVER then\n    ---@param player Player\n    ---@return table   -- player data\n    ---@return integer -- version of data in storage\n    function easyStorageAPI.GetPlayerData(player)\n        local all_data = Storage.GetPlayerData(player)\n        local compressed_data = all_data[COMPRESSED_DATA_KEY]\n        -- data not set yet...\n        if not compressed_data then\n            return {}, STORAGE_VERSION\n        end\n        local data = decompress(compressed_data)\n        local version = data[VERSION_KEY]\n        if version ~= STORAGE_VERSION then\n            warn(format(\"data in Storage is not of the current version: %d, data version is: %d\", STORAGE_VERSION, version))\n        end\n        data[VERSION_KEY] = nil\n        return data, version\n    end\n\n    ---@param player Player\n    ---@param data table\n    ---@return StorageResultCode\n    function easyStorageAPI.SetPlayerData(player, data)\n        assert(player and type(player) == \"userdata\" and Object.IsA(player, \"Player\"), \"first arg must be a player\")\n        assert(type(data) == \"table\", \"second arg ust be a table\")\n        data[VERSION_KEY] = STORAGE_VERSION\n        local compressed_data = compress(data)\n        local all_data = {[COMPRESSED_DATA_KEY] = compressed_data}\n        local storage_size = Storage.SizeOfData(all_data)\n        if storage_size > MAX_STORAGE_DATA_SIZE then\n            warn(\"storage size of data too big: %d (max: %d)\", storage_size, MAX_STORAGE_DATA_SIZE)\n            return StorageResultCode.EXCEEDED_SIZE_LIMIT\n        end\n        return Storage.SetPlayerData(player, all_data), storage_size\n    end\n\n    ---@param player Player\n    ---@return table   -- player data\n    ---@return integer -- version of data in storage\n    function easyStorageAPI.GetSharedPlayerData(player)\n        if not SHARED_STORAGE_KEY then\n            warn(\"Custom Property: @easyData:SHARED_STORAGE_KEY (NetReference) was not set\")\n            return nil\n        end\n        local all_data = Storage.GetSharedPlayerData(SHARED_STORAGE_KEY, player)\n        local compressed_data = all_data[COMPRESSED_DATA_KEY]\n        -- data not set yet...\n        if not compressed_data then\n             return {}, SHARED_STORAGE_VERSION\n        end\n        local data = decompress(compressed_data)\n        local version = data[VERSION_KEY]\n        if version ~= SHARED_STORAGE_VERSION then\n            warn(format(\"data in Shared Storage is not of the current version: %d, data version is: %d\", STORAGE_VERSION, version))\n        end\n        data[VERSION_KEY] = nil\n        return data, version\n    end\n\n    ---@param player Player\n    ---@param data table\n    ---@return StorageResultCode\n    function easyStorageAPI.SetSharedPlayerData(player, data)\n        if not SHARED_STORAGE_KEY then\n            warn(\"Custom Property: @easyData:SHARED_STORAGE_KEY (NetReference) was not set\")\n            return StorageResultCode.STORAGE_DISABLED\n        end\n        assert(player and type(player) == \"userdata\" and Object.IsA(\"Player\"), \"first arg must be a player\")\n        assert(type(data) == \"table\", \"second arg ust be a table\")\n        data[VERSION_KEY] = STORAGE_VERSION\n        local compressed_data = compress\n        local all_data = {[COMPRESSED_DATA_KEY] = compressed_data}\n        local storage_size = Storage.SizeOfData(all_data)\n        if storage_size > MAX_STORAGE_DATA_SIZE then\n            warn(\"storage size of data too big: %d (max: %d)\", storage_size, MAX_STORAGE_DATA_SIZE)\n            return StorageResultCode.EXCEEDED_SIZE_LIMIT\n        end\n        return Storage.SetSharedPlayerData(SHARED_STORAGE_KEY, player, data)\n    end\nend\n\n-- local spack = string.pack\n-- local rand = math.random\n-- local concat = table.concat\n-- local function data64K_test()\n--     local data = {}\n--     for _ = 1, (1 << 16) / 8 do\n--         data[#data + 1] = spack(\"d\", rand())\n--     end\n--     data = concat(data)\n--     local c = compress({data})\n--     local u = decompress(c)\n--     assert(u[1] == data)\n-- end\n-- local t1 = os.clock()\n-- data64K_test()\n-- local t2 = os.clock()\n-- print(\"data64K_test\", t2 - t1)\n\n\nreturn easyStorageAPI\n"
      }
      VirtualFolderPath: "easyStorage"
    }
    PrimaryAssetId {
      AssetType: "None"
      AssetId: "None"
    }
  }
  Marketplace {
    Id: "97d0f463a6fb4b388acedd457f59088b"
    OwnerAccountId: "eec0239c0d644f5bb9f59779307edb17"
    OwnerName: "zoonior"
  }
  SerializationVersion: 101
}
IncludesAllDependencies: true
